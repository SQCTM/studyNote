# 分层和合成机制：CSS动画

[TOC]

## 显示器

每个显示器有固定的刷新频率，通常是60HZ即每秒更新60张图片，更新的图片都来自于显卡中一个叫**前缓冲区**的地方，然后显示器将读取的图像显示到显示器上

- **显卡**
  - 显卡负责合成新的图像并将图像保存到**后缓冲区**。一旦显卡把合成的图像写到后缓冲区系统就会**让后缓冲区和前缓冲区互换**，这样就能保证显示器能读取到最新显卡合成的图像
  - 通常情况下显卡的更新频率和显示器的刷新频率一致，但有时在一些复杂的场景中显卡处理一张图片的速度会变慢，造成视觉上的卡顿



## 帧和帧率

在进行滚动或缩放操作时，渲染引擎会通过渲染流水线生成新的图片并发送到显卡的后缓冲区。渲染流水线生成的**每一幅图片即为一帧**，**每秒更新了多少帧为帧率**

- **卡顿**

  - **问题**

    由于用户很容易观察到那些丢失的帧，如果在一次动画过程中渲染引擎生成某些帧的时间过久用户就会感受到卡顿，这样用户体验感很不好

  - **策略之一**

    要解决卡顿问题就要解决每帧生成时间过久的问题，Chrome引入了分层和合成机制，分层和合成机制代表了当今最先进的渲染技术

- **生成一帧图像**

  - **生成方式**

    - **重排**：需要重新根据CSSOM和DOM计算布局树，会让整个渲染流水线每个阶段都执行一遍
    - **重绘**：不用重新布局，需要重新计算绘制信息并触发绘制操作后的一系列操作
    - **合成**：不需要触发布局和绘制两个阶段，如果采用GPU则合成效率非常高

    *通常渲染路径越长，生成图像花费时间越多

  - **合成**

    Chrome中的合成技术可以用三个词来概括：**分层**、**分块**和**合成**



## 分层和合成

- 有时页面要实现一些复杂的动画效果，若没有采用分层机制，从布局树直接生成目标图片的话则每次页面有很小变化时都会触发重排或重绘机制，严重影响页面的渲染效率

- 将素材分解为多个图层的操作即**分层**，最后将这些图层合并到一起的操作即**合成**，所以**分层和合成通常是一起使用的**

- **分层和合成机制的实现**

  - **分层**

    体现在生成布局树之后，渲染引擎会根据布局树的特点将其转换为层树，层树是渲染流水线后续流程的基础结构，层树的每个节点都对应着一个图层，下一步的绘制阶段就依赖于层树中的节点

  - **合成**

    绘制阶段完成组成绘制列表之后就进入光栅化阶段来按照绘制列表中的指令生成图片，每一图层都对应一张图片，合成线程有了这些图片后会将这些图片合成为“一张”图片，并最终将生成的图片发送到后缓冲区



## 分块

分层从宏观上提升了渲染效率，分块从微观层面提升了渲染效率，合成线程会将每个图层分割为大小固定的图块然后优先绘制靠近视口的图块，这样就大大加速页面的显示速度

- **纹理上传**

  有时即使只绘制优先级最高的图块也要耗费不少时间，这是因为从计算机内存上传到GPU内存的操作会比较慢

- **解决**

  为了解决这个问题Chrome在首次合成图块时使用一个低分辨率的图片，比如可以是正常分辨率的一半，分辨率减少一半纹理就减少了四分之三，在首次显示页面内容时将这个低分辨率的图片显示出来，然后合成器继续绘制正常比例的网页内容，当正常比例的网页内容绘制完成后再替换掉当前显示的低分辨率内容



## 利用分层技术优化代码

CSS动画渲染引擎会为该元素单独实现一帧，等变换发生时渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就大大提升了渲染的效率，因此CSS动画比JS动画高效

- **缺点**

  每当渲染引擎为一个元素准备一个单独层时它占用的内存也会大大增加，因为从层树开始后续每个阶段都会多一个层结构，这些都需要额外的内存