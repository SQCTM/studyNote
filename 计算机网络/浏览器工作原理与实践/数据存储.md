# 数据存储

[TOC]

## JavaScript语言类型

JavaScript是**动态语言**以及**弱类型语言**

- **静态类型与动态类型**

  - **静态语言**：在使用前需要确认其变量数据类型
  - **动态语言**：在运行过程中需要检查数据类型

- **强类型与弱类型**

  - **强类型**：不支持隐式类型转换
  - **弱类型**：支持隐式类型转换

  *隐式类型转换指可以将变量赋值给另一个不同类型的变量，编译器会自行悄悄进行类型转换



## JavaScript数据类型

- **数据类型**

  一共8种

  - **Boolean**
  - **Null**
  - **Undefined**
  - **Number**
  - **BigInt**：可以用任意精度表示整数，即使超出Number的安全整数范围限制也可以安全地存储和操作
  - **String**
  - **Symbol**：符号类型是唯一的且不可修改的，通常用作Object的key
  - **Object**

  *前7种为原始类型，最后一个为引用类型

- **要点**

  - 使用typeof检测Null类型时返回的为Object
  - Object由键值对组成，其中值可以是任何类型



## 内存空间

- **内存空间种类**

  - **代码空间**：存储可执行代码
  - **栈空间**：调用栈
  - **堆空间**

- **堆空间和栈空间**

  ```javascript
  function foo() {
      var a = '极客时间';
      var b = a;
      var c = {
          name: '极客时间'
      }
      var d = c
  }
  ```

  函数执行到最后一行调用栈情况如图：

  ![数据存储](F:\前端笔记\studyNote\images\数据存储.jpg)

  - 原始类型的数据值直接保存在栈中；引用类型的值存放在堆中，而栈中存放着引用该值的地址
  - 原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址

- **区分栈和堆两个存储空间的原因**

  - js引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间很大所有数据都存放在其中会**影响上下文切换的效率**，进而**影响到整个程序的执行效率**
  - 通常情况下栈空间都不会设置太大，主要用来存放一些原始类型的小数据
  - 引用类型数据占用空间大，堆空间很大，能存放很多大的数据，但缺点是**分配内存和回收内存都会占用一定时间**



## 闭包

```JavaScript
function foo(){
    var myname = '123';
    let test1 = 1;
    const test2 = 2;
    var innerBar = {
        setName: function(newName){
            myname = newName;
        },
        getName: function(){
            console.log(test1);
            return myname;
        }
    }
    return innerBar;
}
var bar = foo();
bar.setName('456');
console.log(bar.getName());
```

- **以内存模型角度分析代码流程**：
  1. 当JS引擎执行到foo函数时，首先会编译并创建一个空执行上下文
  2. 编译过程中，遇到内部setName，JS引擎对内部函数做一次快速词法扫描，发现该内部函数引用了foo函数中的myname变量，由于内部函数引用了外部函数的变量，所以JS引擎判断这是一个闭包，就**在堆空间创建了一个”closure(foo)“的对象**（这是一个内部对象，JS是无法访问的），用来保存myname变量
  3. 接着扫描到getName方法，发现该函数内部引用变量test1，于是JS引擎又将test1添加到”closure(foo)“对象中。这时堆中的”closure(foo)“对象中就包含了myname和test1两个变量了
  4. 由于test2并没有被内部函数引用，所以test2依然保存在调用栈中
- **产生闭包的核心**
  1. 预扫描内部函数
  2. 内部函数引用的外部变量保存在堆中

