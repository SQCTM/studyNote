# HTTPS

[TOC]

## HTTP的中间人攻击

HTTP是**明文传输**，设计HTTP协议的目的是为了传输超文本文件，在传输过程中的每一环节数据都有可能被窃取或篡改，这意味着浏览器和服务器之间可能有个中间人，使用HTTP传输的内容很容易被中间人窃取、伪造和篡改，这种攻击方式叫**中间人攻击**



## 在HTTP协议栈中引入安全层

给HTTP引入加密方案，从HTTP协议栈层面来看在TCP和HTTP之间插入一个安全层，所有经过安全层的数据都会被加密或者解密

![HTTP与HTTPS](F:\前端笔记\studyNote\images\HTTP与HTTPS.jpg)

- **安全层职责**
  - 对发起HTTP请求的数据进行加密操作
  - 对接收到HTTP的内容进行解密操作



## **HTTPS协议进阶**

### 第一版：使用对称加密

对称加密指**加密和解密都使用的是相同的密钥**

- **HTTPS建立安全连接**

  即HTTPS协商加密方式，具体过程如下：

  1. 浏览器发送它所支持的加密套件列表和一个随机数client-random，加密套件指加密的方法，加密套件列表指浏览器能支持多少种加密方法列表
  2. 服务器从加密套件列表中选取一个加密套件，然后还会生成另一个随机数service-random，并将该随机数和加密套件列表返回给浏览器
  3. 最后浏览器和服务器分别返回确认消息

- **生成密钥**

  这样浏览器端和服务器端都有相同的两个随机数，它们再使用相同的方法**将两个随机数混合起来生成一个密钥master secret**，有了密钥和加密套件后双方就可以进行数据的加密传输

- **缺点**

  传输两个随机数的过程是明文的，黑客可以拿到协商的加密套件和双方的随机数，由于利用随机数合成密钥的算法是公开的，所以黑客拿到随机数后也可以合成密钥，数据依然可以被破解，那么黑客也可以使用密钥来伪造或篡改数据

  

### 第二版：使用非对称加密

非对称加密算法**有A、B两把密钥，如果用A密钥来加密则只能用B密钥来解密，反之若用B密钥来加密则只能用A密钥来解密**

- **加密请求流程**

  服务器会将其中一个密钥通过明文的形式发送给浏览器，这个密钥称为**公钥**，服务器自己留下的那个密钥称为**私钥**。公钥是每个人都能获取到的，而私钥只有服务器才能知道，不对任何人公开

  1. 浏览器发送非对称加密套件列表给服务器
  2. 服务器上有**用于浏览器加密的公钥**和**服务器解密HTTP数据的私钥**，公钥是给浏览器加密使用的，服务器会**选择一个加密套件和公钥一道发送给浏览器**
  3. 浏览器和服务器返回确认消息

  这样就解决了第一版的问题，浏览器有了服务器的公钥向服务器端发送数据时可以用该公钥来加密数据，由于公钥加密的数据只有私钥才能解密，所以即便黑客截获了数据和公钥也无法解密数据

- **缺点**

  - **非对称加密的效率太低**

    这严重影响到加解密数据的速度，进而影响到用户打开页面的速度

  - **无法保证服务器发送给浏览器的数据安全**

    虽然浏览器可以使用公钥来加密，但服务器端只能采用私钥来加密，私钥加密只有公钥能解密，但黑客可以获取公钥，这样不能保证服务器端数据的安全

    

### 第三版：对称加密和非对称加密搭配使用

在传输数据阶段使用对称加密，但对称加密的密钥采用非对称加密来传输

- **建立连接流程**

  1. 浏览器向服务器发送对称加密套件列表、非对称加密套件列表和随机数client-random
  2. 服务器保存随机数，选择对称加密和非对称加密的套件，然后生成随机数service-random，向浏览器发送选择的加密套件、service-random和公钥
  3. 浏览器保存公钥，并利用两个随机数计算出pre-master，然后利用公钥对pre-master加密，并向服务器发送加密后的数据
  4. 服务器拿出私钥解密pre-master，并返回确认消息

- **生成密钥**

  建立连接后服务器和浏览器就有了共同的client-random、service-random和pre-master，然后服务器和浏览器会使用这三组随机数生成**对称密钥**。因为服务器和浏览器使用同一套方法来生成密钥，所以最终生成的密钥也是相同的

*pre-master是经过公钥加密之后传输的，所以黑客无法获取到它，这样黑客就无法生成密钥也就无法破解传输过程中的数据



### 第四版：添加数字证书

当黑客通过DNS劫持将一个网站的IP地址替换成黑客的IP地址，用户访问该网站时访问的就是黑客的服务器，黑客可以在自己的服务器上实现公钥和私钥，而浏览器完全不知道，因此服务器需要**数字证书**向浏览器证明自己的身份

- **数字证书的作用**

  - 通过数字证书向浏览器证明服务器的身份
  - 数字证书里面包含了服务器公钥

- **含有数字证书的HTTPS的请求流程相较于第三版的改变**

  - 服务器没有直接返回公钥给浏览器而是返回了数字证书，而**公钥是包含在数字证书中的**
  - 浏览器端多了一个证书验证的操作，验证了证书之后才继续后续流程

  ![完整HTTPS请求流程](F:\前端笔记\studyNote\images\完整HTTPS请求流程.jpg)

  通过引入数字证书就实现了服务器的身份认证功能，这样即使黑客伪造了服务器，但由于证书是无法伪造的，所以依然无法欺骗用户

- **数字证书的申请和验证**
  
  - **申请**
  
    数字证书需要由权威机构**CA**颁发，向CA申请流程：
  
    1. 需要准备一套私钥和公钥，私钥留着自己使用
  
    2. 向CA提交公钥、公司、站点等信息并等待认证，认证过程可能收费
  
    3. CA通过线上、线下等多种渠道来验证信息的真实性，如公司是否存在、企业是否合法、域名是否归属该企业等
  
    4. 如果信息审核通过，CA会签发认证的数字证书，包含公钥、组织信息、CA信息、有效时间、证书序列号等，这些信息都是明文，同时包含一个CA生成的数字签名
  
       *CA使用Hash函数来计算提交的明文信息并得出信息摘要，然后再使用它的私钥对信息摘要进行加密，加密后的密文就是CA颁发的数字签名
  
  - **浏览器验证数字证书**
  
    浏览器读取证书中相关的明文信息，采用CA签名时相同的Hash函数来计算并得到信息摘要A，然后再利用对应CA的公钥解密签名数据，得到信息摘要B，再对比A和B，如果一致则可以确认证书合法。同时浏览器还会验证证书相关的域名信息、有效时间等
- **注意事项**
  
  - 申请数字证书不需要提供私钥，要确保私钥永远只能由服务器掌握
  - 数字证书最核心的是CA使用它的私钥生成数字签名
  - 内置CA对应的证书称为**根证书**，根证书是最权威的机构，它们自己为自己签名，这称为**自签名证书**