# setTimeout

[TOC]

是一个定时器，用来指定某个函数在多少毫秒后执行，会返回一个整数，表示定时器的编号，可以通过该编号来取消定时器



## 浏览器如何实现定时器

定时器设置回调函数需要在指定的时间间隔内被调用，而消息队列中的任务是按照顺序执行的，所以**不能直接将定时器的回调函数添加到消息队列中**

- **延迟队列**

  Chrome除了正常使用消息队列外还有一个**延迟队列**，维护需要延迟执行的任务列表，渲染进程会将定时器的回调任务添加到延迟队列中

- **实现**

  1. 当通过JS调用setTimeout设置回调函数时，渲染进程会创建一个回调任务，包含了回调函数、当前发起时间、延迟执行时间
  2. 创建好回调任务之后将该任务添加到延迟执行队列中
  3. 处理完消息队列中的一个任务之后，根据发起时间和延迟时间计算出到期的任务，然后依次执行延迟队列中到期的任务，等到期的任务执行完成后再继续下一个循环过程
  4. 设置一个定时器JS引擎会返回一个定时器的ID，任务还没有被执行时可以调用clearTimeout函数传入ID作为参数取消执行，浏览器内部会从延迟队列中通过ID查找到对应的任务并删除



## 使用的注意事项

- 如果当前任务执行时间过久，会影响延迟到期定时器任务的执行

- 如果setTimeout存在嵌套调用，系统会设置最短时间间隔为4毫秒

- 未激活的页面setTimeout执行最小间隔为1000毫秒，目的是为了优化后台页面的加载损耗以及降低耗电量

- 延时执行时间有最大值，如果超出最大值就会溢出，导致定时器被立即执行

- 使用setTimeout设置的回调函数中的this不符合直觉，如果被setTimeout推迟执行的回调函数是某个对象的方法，那么该方法中的this关键字将指向全局环境，而不是定义时所在的那个对象

  - **解决**

    - 将对象方法放在匿名函数中执行

      ```JavaScript
      //1.箭头函数
      setTimeout(() => {
          obj.xxx();
      }, 1000);
      
      //2.function函数
      setTimeout(function() {
          obj.xxx();
      }, 1000);
      ```

    - 使用bind方法将对象方法绑定在对象上

      ```JavaScript
      setTimeout(obj.xxx.bind(obj), 1000);
      ```

      

