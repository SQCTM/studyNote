# HTTP/3

[TOC]

## HTTP/3协议栈

![HTTP3协议栈](F:\前端笔记\studyNote\images\HTTP3协议栈.jpg)

HTTP/3把下层的TCP换成了UDP。因为UDP是无序的，包之间没有依赖关系，所以就从根本上解决了“队头阻塞“



## QUIC协议

HTTP/2没有办法解决TCP固有的队头阻塞问题，于是发明了新协议QUIC，真正完美地解决了队头阻塞问题

- **特点**
  - QUIC基于UDP，UDP是“**无连接**”的，不需要“握手”和“挥手”，所以比TCP更快，而且UDP是**无序的**，包之间没有依赖关系，所以就从根本上解决了“队头阻塞“
  - QUIC基于UDP实现了**可靠传输**，保证数据一定能够抵达目的地。它还引入了类似 HTTP/2 的“流”和“多路复用”，单个“流”是有序的，可能会因为丢包而阻塞，但其他“流”不会受到影响
  - QUIC全面采用**加密通信**，可以很好地抵御窜改和“协议僵化”
  - QUIC直接**应用了TLS1.3**，QUIC不是建立在TLS之上，而是**内部“包含”了 TLS**。它使用自己的帧“接管”了TLS里的“记录”，握手消息、警报消息都不使用 TLS 记录，直接封装成 QUIC 的帧发送，省掉了一次开销
- **内部细节**
  - QUIC的基本数据传输单位是**包**和**帧**，一个包由多个帧组成，包面向的是“连接”，帧面向的是“流”
  - QUIC**使用不透明的“连接 ID”来标记通信的两个端点**，客户端和服务器可以自行选择一组ID来标记自己，这样就解除了 TCP 里连接对“IP地址 + 端口”（即常说的四元组）的强绑定，支持“**连接迁移**”
  - QUIC 的**帧**里有多种类型，PING、ACK 等帧用于管理连接，而 STREAM 帧专门用来实现流
  - QUIC 里的**流**是帧的序列，分为双向流和单向流



## HTTP/3协议

因为 QUIC 本身就已经支持了加密、流和多路复用，所以 HTTP/3 的工作减轻了很多，把流控制都交给 QUIC 去做。调用的不再是 TLS 的安全接口，也不是 Socket API，而是专门的 QUIC 函数。不过这个“QUIC 函数”还没有形成标准，必须要绑定到某一个具体的实现库

HTTP/3 里仍然使用流来发送“请求 - 响应”，但它自身不需要像 HTTP/2 那样再去定义流，而是直接使用 QUIC 的流



## HTTP/3服务发现

HTTP/3没有指定默认的端口号，如果要发现HTTP/3则需要用到HTTP/2里的**扩展帧**

浏览器需要先用HTTP/2协议连接服务器，然后服务器可以在启动HTTP/2连接后发送一个“**Alt-Svc**”帧，包含一个“h3=host:port”的字符串，告诉浏览器在另一个端点上提供等价的HTTP/3服务。浏览器收到“Alt-Svc”帧，会使用QUIC异步连接指定的端口，如果连接成功，就会断开HTTP/2连接，改用新的HTTP/3收发数据