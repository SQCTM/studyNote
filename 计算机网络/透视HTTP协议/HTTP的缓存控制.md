# HTTP的缓存控制

[TOC]

HTTP传输的每一个环节基本上都会有缓存，基于“请求-应答”模式的特点可以大致分为客户端缓存和服务器缓存



## 缓存运行机制

1. 浏览器发现缓存无数据，于是发送请求向服务器获取资源
2. 服务器响应请求，返回资源，同时标记资源的有效期
3. 浏览器缓存资源等待下次重用



## 服务器的缓存控制

- **Cache-Control**

  服务器标记资源有效期使用的头字段

  - **max-age**

    生存时间，缓存寿命，单位是秒，时间的计算起点是**响应报文的创建时刻**而不是客户端收到报文的时刻，因此包含了在链路传输过程中所有节点停留的时间 

  - **no-store**

    不允许缓存，用于某些变化非常频繁的数据

  - **no-cache**

    可以缓存，但使用之前必须要去服务器验证是否过期、是否有最新版本

  - **must-revalidate**

    缓存不过期就可以继续使用，但过期了还想使用的话就必须去服务器验证



## 客户端的缓存控制

浏览器也可以发送Cache-Control字段

- 当点击浏览器刷新按钮时，浏览器会在请求头里加上"Cache-Control:max-age=0"，所以浏览器不会使用缓存而是向服务器发送请求
- Ctrl+F5“强制刷新”时，浏览器会在请求头里加上"Cache-Control:no-cache"，含义与"max-age=0"基本一样
- 点击浏览器的前进、后退按钮以及跳转，进行这些重定向动作，浏览器只用最基本的请求头，不带"Cache-Control"字段，所以就会检查缓存，没有发送网络请求，而是读取磁盘上的缓存



## 条件请求

浏览器用"Cache-Control"做缓存控制只能是刷新数据，不能很好地利用缓存数据，又因为缓存会失效，使用前还必须要去服务器验证是否是最新版本

- **请求条件字段**

  HTTP协议定义了一系列"if"开头的请求条件字段，专门用来验证资源是否过期

  - **if-Modified-Since** 与**Last-Modifed**

    - **Last-Modifed**：文件最后修改时间

  - **if-None-Match**与**ETag**

    - **ETag**：资源的一个唯一标识，主要用来解决修改时间无法准确区分文件变化的问题。ETag还有强、弱之分，强ETag要求资源在字节级别必须完全相符，弱ETag在值前有个"W/"标记，只要求资源在语义上没有变化，但内部可能有部分发生了变化

      *使用ETag可以精确的识别资源的变动情况，让浏览器能够更有效地利用缓存

- **过程**

  - 需要第一次的响应报文预先提供“**Last-Modifed**”和“**ETag**”，然后第二次请求时就可以带上缓存的原值，验证资源是否使最新的
  - 如果资源没有变，服务器就回应一个“**304 Not Modified**”，表示缓存依然有效，浏览器就可以更新一下有效期，然后使用缓存