# HTTP/2

[TOC]

## HTTP在HTTP/2的改进

由于HTTPS已经在安全方面做的非常好了，所以HTTP/2的唯一目标就是**改进性能**

 HTTP/2把HTTP分解成了“**语义**”和“**语法**”两个部分：

- **“语义”层不做改动**，与 HTTP/1完全一致（即 RFC7231），基于HTTP的上层应用也不需要做任何修改，可以无缝转换到 HTTP/2，而且HTTP/2没有在URI里引入新的协议名，仍然用“http”表示明文协议

- “语义”保持稳定，HTTP/2**在“语法”层做了“天翻地覆”的改造**，完全变更了HTTP报文的传输格式



### 头部压缩

 HTTP/2没有使用传统的压缩算法，而是开发了专门的“**HPACK**”算法

- **HPACK算法**

  在客户端和服务器两端建立“字典”又称“索引表”，用索引号表示重复的字符串，还釆用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率，压缩和解压缩就是查表和更新表的操作

- 为了方便管理和压缩，HTTP/2 废除了原有的起始行概念，把起始行里面的请求方法、URI、状态码等统一转换成了头字段的形式，即伪头字段。而起始行里的版本号和错误原因短语因为没什么大用，顺便也给废除了。为了与“真头字段”区分开来，**“伪头字段”会在名字前加一个“:”**

- **静态表和动态表**

  现在 HTTP 报文头就简单了，全都是“Key-Value”形式的字段，于是 HTTP/2 就为一些最常用的头字段定义了一个只读的“**静态表**”。但如果表里只有Key没有Value，或者是自定义字段根本找不到，这就要用到“**动态表**”，它添加在静态表后面，结构相同，但会在编码解码的时候随时更新



### 二进制格式

- **好处**

  大大方便了计算机的解析。二进制里只有“0”和“1”，可以严格规定字段大小、顺序、标志位等格式，解析起来没有歧义，实现简单，而且体积小、速度快，做到“内部提效”

- **二进制“帧”**

  以二进制格式为基础，HTTP/2把TCP协议的部分特性挪到了应用层，把原来的“Header+Body”的消息“打散”为数个小片的二进制“帧”（Frame），**用“HEADERS”帧存放头数据、“DATA”帧存放实体数据**

  - **帧长度**：帧开头是 3 个字节的长度（但不包括头的 9 个字节），默认上限是2^14，最大是2^24，HTTP/2的帧通常不超过16K，最大是16M
  - **帧类型**
    - **数据帧**：HEADERS帧和DATA帧，存放HTTP报文
    - **控制帧**：SETTINGS、PING、PRIORITY等，用来管理流
  - **帧标志**：第5个字节，可以保存8个标志位，携带简单的控制信息。常用的标志位有END_HEADERS表示头数据结束、END_STREAM表示单方向数据发送结束
  - **流标识符**：报文头里最后4个字节，接收方使用它就可以从乱序的帧里**识别出具有相同流ID的帧序列**，按顺序组装起来实现了虚拟的“流”



### 虚拟的“流”

- **目的**

  组装到达目的地的消息碎片帧

- **“流”概念**

  是**二进制帧的双向传输序列**，同一个消息往返的帧会分配一个唯一的流ID。可以把它想象成一个虚拟的“数据流”，在里面流动的是一串有先后顺序的数据帧，这些数据帧按照次序组装起来就是 HTTP/1 里的请求报文和响应报文

- **多路复用**

  因为“流”是虚拟的，实际上并不存在，所以HTTP/2就可以在一个 TCP 连接上用“流”同时发送多个“碎片化”的消息，这就是常说的“多路复用”（ Multiplexing）——**多个往返通信都复用一个连接来处理**

- **解决“队头阻塞”**

  在“流”的层面上看，消息是一些有序的“帧”序列，而在“连接”的层面上看，消息却是乱序收发的“帧”。多个请求 /响应之间没有了顺序关系，不需要排队等待，也就不会再出现“队头阻塞”问题，降低了延迟，大幅度提高了连接的利用率

- **控制帧**

  为了更好地利用连接，加大吞吐量，HTTP/2还添加了一些控制帧来管理虚拟的“流”，实现了优先级和流量控制

- **服务器推送**

  HTTP/2 还在一定程度上改变了传统的“请求 - 应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求 HTML 的时候就提前把可能会用到的 JS、CSS 文件发给客户端，减少等待的延迟，这被称为“服务器推送”

- **“流”的特点**

  - 流是**可并发的**，一个 HTTP/2 连接上可以同时发出多个流传输数据，也就是并发多请求，实现“多路复用”
  - 客户端和服务器都可以创建流，双方互不干扰
  - 流是**双向**的，一个流里面客户端和服务器都可以发送或接收数据帧，也就是一个“请求\- 应答”来回
  - 流之间没有固定关系，彼此独立，但流内部的帧是有严格顺序的
  - 流**可以设置优先级**，让服务器优先处理，比如先传 HTML/CSS，后传图片，优化用户体验
  - 流ID不能重用，只能顺序递增，**客户端发起的ID是奇数，服务器端发起的ID是偶数**
  - 在流上发送**“RST_STREAM”帧可以随时终止流**，取消接收或发送
  - **第0号流**比较特殊，不能关闭，也不能发送数据帧，只能发送控制帧，用于流量控制



### 强化安全

- HTTP/2 延续了 HTTP/1 的“明文”特点，可以像以前一样使用明文传输数据，不强制使用加密通信，不过格式还是二进制，只是不需要解密。但事实上HTTP/2是加密的，互联网上通常所能见到的HTTP/2都是使用“https”协议名，跑在 TLS 上面

- 为了区分“加密”和“明文”这两个不同的版本，HTTP/2协议定义了两个字符串标识符：
  - “**h2**”表示加密的HTTP/2
  - “**h2c**”表示明文的 HTTP/2，多出的字母“c”的意思是“clear text”

- 加密版本的HTTP/2在安全方面做了强化，**要求下层的通信协议必须是TLS1.2以上**，还要支持前向安全和SNI，并且把几百个弱密码套件列入了“黑名单”，相当于底层用的是“TLS1.25”



### 协议栈

![HTTP1、HTTPS、HTTP2协议栈对比](F:\前端笔记\studyNote\images\HTTP1、HTTPS、HTTP2协议栈对比.jpg)

如上是HTTP/1、HTTPS、HTTP/2协议栈比较图

HTTP/2建立在“HPack”“Stream”“TLS1.2”基础上，比HTTP/1、HTTPS复杂了一些

