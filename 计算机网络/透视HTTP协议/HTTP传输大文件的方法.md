# HTTP传输大文件的方法

[TOC]

## 数据压缩

- **优点**

  网速的加速效果非常明显

- **缺点**

  gzip 等压缩算法通常只对文本文件有较好的压缩率，而图片、音频视频等多媒体数据本身就已经是高度压缩的，再用 gzip 处理也不会变小（甚至还有可能会增大一点），所以它就失效了。不过数据压缩在处理文本的时候效果还是很好的，所以各大网站的服务器都会使用这个手段作为“保底“



## 分块传输

“**chunked**”分块传输编码，在响应报文里用头字段“Transfer-Encoding: chunked”来表示，意思是报文里的body部分不是一次性发过来的，而是分成了许多的块（chunk）逐个发送

*Transfer-Encoding: chunked和Content-Length这两个字段是互斥的，响应报文里这两个字段不能同时出现，一个响应报文的传输要么是长度已知，要么是长度未知（chunked）

- **分块传输的编码规则**

  -  每个分块包含两个部分，长度头和数据块
  - 长度头是以 CRLF（回车换行，即\r\n）结尾的一行明文，用 16 进制数字表示长度
  - 数据块紧跟在长度头后，最后也用CRLF结尾，但数据不包含CRLF
  - 最后用一个长度为 0 的块表示结束，即“0\r\n\r\n”

  ![数据分块传输编码规则](F:\前端笔记\studyNote\images\数据分块传输编码规则.jpg)

浏览器在收到分块传输的数据后会自动按照规则去掉分块编码，重新组装出内容



## 范围请求

允许客户端在请求头里使用专用字段来表示只获取文件的一部分，相当于是客户端的“化整为零“。

- **服务器对范围请求的支持**

  范围请求不是 Web 服务器必备的功能，可以实现也可以不实现

  - 如果服务器**支持**范围请求，需要在响应头里使用字段“**Accept-Ranges: bytes**”
  - 如果**不支持**，服务器可以发送“**Accept-Ranges: none**”，或**不发送“Accept-Ranges”字段**，这样客户端就认为服务器没有实现范围请求功能，只能收发整块文件

- **Range字段**

  请求头Range是**范围请求的专用字段**，格式是“**bytes=x-y**”，其中的**x和y是以字节为单位的数据范围**，表示的是**偏移量**，范围从0计数

  Range格式很灵活，例如假设文件是100个字节：

  - ”0-”表示从文档起点到文档终点，相当于“0-99”，即整个文件
  - “10-”是从第 10 个字节开始到文档末尾，相当于“10-99”
  - “-1”是文档的最后一个字节，相当于“99-99”
  - “-10”是从文档末尾倒数 10 个字节，相当于“90-99”

- **服务器收到Range字段后需要做的事**

  1. 检查范围是否合法，若不合法则返回416状态码
  2. 如果范围正确，服务器根据Range头计算偏移量，读取文件的片段，返回状态码206，表示body只是原数据的一部分
  3. 服务器要添加一个响应头字段**Content-Range**告知片段的实际偏移量和资源总大小，格式是“**bytes x-y/length**”，例如对于“0-10”的范围请求，值就是“bytes 0-10/100”
  4. 发送数据，直接把片段用TCP发给客户端，一个范围请求就算是处理完了



## 多段数据

范围请求一次性获取多个片段数据，这种情况需要使用一种特殊的 MIME 类型：“**multipart/byteranges**”，表示报文的body是由多段字节序列组成的，并且还要用一个参数“**boundary=xxx**”给出段之间的分隔标记

- **格式**

  需要用分隔标记boundary来区分不同的片段，每一个分段必须以“- -boundary”开始（前面加两个“-”），之后要用“Content-Type”和“Content-Range”标记这段数据的类型和所在范围，然后就像普通的响应头一样以回车换行结束，再加上分段数据，最后用一个“- -boundary- -”（前后各有两个“-”）表示所有的分段结束

  ![数据分块传输](F:\前端笔记\studyNote\images\数据分块传输多段数据.jpg)