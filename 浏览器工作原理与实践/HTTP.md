# HTTP

[TOC]

HTTP是浏览器中最重要且使用最多的协议，是浏览器和服务器之间的通信语言



## HTTP/0.9

用来在网络之间传递HTML超文本的内容，所以被称为**超文本传输协议**。它采用了基于请求响应的模式，从客户端发出请求，服务器返回数据

- **请求流程**
  1. 客户端先根据IP地址、端口和服务器建立TCP连接，而建立连接的过程就是TCP协议三次握手的过程
  2. 建立好连接之后，会发送一个GET请求行的信息
  3. 服务器接受请求信息之后，读取对应HTML文件，并将数据以ASCII字符流返回给客户端
  4. HTML文档传输完成后，断开连接
- **实现的特点**
  - 只有一个请求行，没有HTTP请求头和请求体，只需要一个请求行就可以完整表达客户端的需求
  - 服务器没有返回头信息，因为服务器端并不需要告诉客户端太多信息，只需要返回数据就可以了
  - 返回的文件内容是以ASCII字符流来传输的，因为都是HTML格式的文件，所以使用ASCII字节码来传输是最合适的



## HTTP/1.0

**支持多种类型的文件下载**是HTTP/1.0的核心诉求，文件格式不仅仅局限于ASCII编码，还有很多其他类型编码的文件

- **下载多种类型文件的实现**

  HTTP/1.0引入了请求头和响应头，都是以Key-Value形式保存，在HTTP发送请求时会带上请求头信息，服务器返回数据时，会先返回响应头信息

- **通过请求头和响应头来支持多种不同类型的数据**

  - **解决的问题**
    - 让浏览器知道服务器返回的数据是什么类型，于是浏览器能根据不同数据类型做针对性的处理
    - 浏览器可以告诉服务器它想要的语言版本页面，服务器可以对不同地区提供不同的语言版本，提供了国际化的支持
    - 浏览器可以知道文件的编码类型，能够准确地读取文件
  - **新增的特性**
    - 引入了**状态码**，状态码通过响应行的方式来通知浏览器的，告诉浏览器了服务器最终处理该请求的情况
    - 提供了**Cache机制**，用来缓存已经下载过的数据，减轻了服务器的压力
    - 在请求头的中加入了**用户代理**的字段，可以让服务器统计客户端的基础信息



## HTTP/1.1

- **改进**

  - **持久连接**

    - **HTTP/1.0问题**

      每进行一次HTTP通信都要经历建立TCP连接、传输HTTP数据和断开TCP连接三个阶段，如果在下载每个文件时都要经历这些步骤会增加大量无谓的开销

    - **HTTP/1.1解决**

      HTTP/1.1中增加了持久连接的方法，在一个TCP连接上可以传输多个HTTP请求，只要浏览器或服务器没有明确断开连接该TCP连接就会一直保持

  - **不成熟的HTTP管线化**

    - **问题**

      持久连接虽然能减少TCP的建立和断开次数，但它需要等待前面的请求返回之后才能进行下一次请求，若TCP通道中某个请求因为某些原因没有及时返回，那么会阻塞后面所有的请求，即**队头阻塞**

    - **解决**

      HTTP/1.1通过**管线化**来解决队头阻塞问题，管线化指将多个HTTP请求整批提交给服务器的技术，虽然可以整批发送请求，不过服务器依然需要根据请求顺序来回复浏览器的请求

      *一些浏览器都做过管线化的试验但最终都放弃了该技术

  - **提供虚拟主机的支持**

    - **HTTP/1.0问题**

      在HTTP/1.0中每个域名绑定了一个唯一的IP地址，因此一个服务器只能支持一个域名。但随着虚拟主机技术的发展，需要实现在一台物理主机上绑定多个虚拟主机，每个虚拟主机都有自己家的单独域名，这些单独域名都共用同一个IP地址

    - **HTTP/1.1解决**

      HTTP/1.1的请求头中增加了**Host字段**，用来表示当前的域名地址，这样服务器就可以根据不同的Host值做不同的处理

  - **对动态生成的内容提供了完美的支持**

    - **HTTP/1.0问题**

      HTTP/1.0需要在响应头中设置完整数据大小这样浏览器可以据此来接收数据，但很多页面的内容是动态生成，在传输数据前并不知道最终的数据大小，导致浏览器不知道何时会接收完所有文件数据

    - **HTTP/1.1解决**

      引入**Chunk transfer机制**来解决这个问题，服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志，这样就提供了对动态内容的支持

  - **引入客户端Cookie、安全机制**

- **主要问题**

  HTTP/1.1的核心问题是**对带宽的利用率不理想**，很难将带宽用满。带宽是指每秒最大能发送或者接受的字节数，每秒能发送的最大字节数称为上行带宽，能接收的最大字节数称为下行带宽

  - **原因**

    - **TCP的慢启动**

      TCP建立连接后进入发送数据状态，刚开始TCP协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度直到发送数据的速度达到一个理想状态，这个过程为**慢启动**。慢启动是TCP为了减少网络拥塞的一种策略。慢启动会带来性能问题，耗费时间很长，推迟了首次渲染页面时长

    - **同时开启多条TCP连接会竞争固定的带宽**

      系统同时建立多条TCP连接，带宽充足时每条连接发送或接收速度慢慢增加，不足时就需要动态减慢接收数据的速度，多条TCP连接之间不能协商，因此可能影响关键资源的下载速度

    - **HTTP\1.1队头阻塞问题**

      队头阻塞使得数据不能并行请求，不利于浏览器的优化



## HTTP/2.0

为了解决HTTP/1.1的问题，HTTP/2.0一个域名只使用一个TCP长连接来传输数据来避免多个TCP连接竞争带宽所带来的问题，以及消除队头阻塞问题

HTTP/2.0核心机制为**多路复用机制**

- **多路复用的实现**

  HTTP/2.0添加一个**二进制分帧层**，具体请求和接收过程：

  1. 浏览器准备好请求数据，包括请求行、请求头等信息，如果是POST方法则还有请求体
  2. 数据经过二进制分帧层处理后，会被转换为一个个带有请求ID编号的帧，通过协议栈将这些帧发送给服务器
  3. 服务器接收到所有帧之后，会将所有相同ID的帧合并为一条完整的请求信息
  4. 然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层
  5. 同样二进制分帧层会将这些相应数据转换为一个个带有请求ID编号的帧，经过协议栈发送给浏览器
  6. 浏览器接收到响应帧之后，会根据ID编号将帧的数据提交给对应的请求

- **其他特性**

  - **可以设置请求优先级**
  
    HTTP/2可以在发送请求时标上请求的优先级，服务器接收到请求后会优先处理优先级高的请求
  
  - **服务器推送**
  
    HTTP/2.0可以**直接将数据提前推送到浏览器**。比如当用户请求一个HTML页面，服务器知道该页面会引用几个重要的JS和CSS文件，那么在接收到HTML请求之后附带将这些JS和CSS文件一并发送给浏览器，这样当浏览器解析完HTML文件后就能直接拿到需要的CSS和JS文件，对首次打开页面的速度起到了至关重要的作用
  
  - **头部压缩**
  
    HTTP/2.0对请求头和响应头进行了压缩，传输效率能得到提升



## HTTP/3.0

- **TCP缺陷**

  - **TCP队头阻塞**

    由于单个数据包的丢失而造成的阻塞称为TCP的队头阻塞。HTTP/2中多个请求是跑在一个TCP管道中的，如果其中任意一路数据流中出现了丢包的情况，就会阻塞该TCP连接中所有的请求；而HTTP/1.1支持多个TCP连接，如果一个TCP连接发生了TCP队头阻塞，其他的连接还是可以继续传输数据

    所以随着丢包率的增加，HTTP/2的传输效率会越来越差。测试表明，当系统丢包率达到2%的时候，HTTP/1.1的传输效率反而比HTTP/2表现更好

  - **TCP建立连接的延时**

    TCP握手过程也是影响传输效率的一个重要因素

    - **网络延迟**

      网络延迟又称为RTT，即从浏览器发送一个数据包到服务器，再从服务器返回数据包到浏览器的整个往返时间，这是反映网络性能的一个重要指标

    - **建立TCP连接花费的RTT**

      HTTP/1.0和HTTP/2.0都使用TCP协议来传输，如果使用HTTPS还需要使用TLS协议进行安全传输，也需要一个握手过程，这样就有两个握手延迟过程

      - 建立TCP连接，需要和服务器进行三次握手来确认连接成功，需要消耗1.5个RTT后才能进行数据传输
      - 进行TLS连接，TLS两个版本TLS1.2和TLS1.3，每个版本所花的时间不同，大致需要1~2个RTT

      在传输数据之前需要花掉3~4个RTT，如果服务器和浏览器物理距离近1个RTT的时间可能在10毫秒以内，远的话就可能1个RTT100毫秒以上，用户就能明显地感受到蛮

  - **TCP协议僵化**

    这也是改进TCP协议困难原因

    - **中间设备僵化**

      中间设备包括路由器、防火墙等，它们依赖一些很少升级的软件，这些软件使用了大量的TCP特性，这些功能被设置后就很少更新，所以如果在客户端升级了TCP协议当新协议的数据包经过这些中间设备时，它们可能不理解包的内容，于是数据就会被丢弃

    - **操作系统影响**

      TCP协议都是通过操作系统内核来实现的，应用程序只能使用不能修改。通常操作系统的更新都滞后于软件的更新，因此想自由地更新内核中的TCP协议非常困难

- **QUIC协议**

  HTTP/3.0基于UDP实现了类似于TCP的多路数据流、传输可靠性等功能的QUIC协议

  - **类似TCP的流量控制、传输可靠性功能**

    UDP不提供可靠性的传输，QUIC在UDP的基础上增加了 一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些TCP中存在的特性

  - **集成了TLS加密功能**

    减少了握手所花费的RTT个数

  - **实现了HTTP/2的多路复用功能**

    和TCP不同，QUIC实现了在同一物理连接上可以有多个独立的逻辑数据流。实现了数据流的单独传输，就解决了TCP中队头阻塞的问题

  - **实现了快速握手功能**

    由于QUIC是基于UDP的，所以QUIC可以实现使用0-RTT或1-RTT来建立连接，因此它可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度

- **面临的挑战**

  - 从目前来看，服务器和浏览器端都没有对HTTP/3.0提供比较完整的支持
  - 部署HTTP/3.0也存在非常大的问题。因为系统内核对UDP的优化远远没有达到TCP的优化程度，这也是阻碍QUIC的一个重要原因
  - 中间设备僵化。设备对UDP的优化程度远远低于TCP。据统计使用QUIC协议时大约有3%~7%的丢包率