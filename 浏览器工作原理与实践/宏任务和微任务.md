# 宏任务和微任务

[TOC]

## 宏任务

消息队列中的任务称为宏任务

- **任务种类**

  - **渲染事件**：解析DOM、计算布局、绘制
  - **用户交互事件**：鼠标点击、滚动页面、放大缩小等
  - **JS脚本执行事件**
  - **网络请求完成、文件读写完成事件**

- **事件循环机制执行宏任务流程**

  1. 从多个消息队列中选出一个最老的任务
  2. 循环系统记录任务开始执行的时间，并把老任务设置为当前正在执行的任务
  3. 当任务执行完成后删除当前正在执行的任务，并从对应的消息队列中删除这个老任务
  4. 统计执行完成的时长等信息

- **缺点**

  难以满足对时间精度要求较高的任务，宏任务时间粒度比较大，执行的时间间隔不能精确控制，对于高实时性的需求不太符合

  

## 微任务

是一个需要异步执行的函数，每一个宏任务都关联了一个微任务队列，用来存放微任务。微任务执行时机是在主函数执行结束之后、当前宏任务结束之前

- **微任务的产生**

  - 使用MutationObserver监控某个DOM节点，再通过JS来修改这个节点或添加、删除子节点，当DOM节点发生变化时，会产生DOM变化记录的微任务、
  - 使用Promise，调用Promise.resolve()或Promise.reject()时会产生微任务

- **微任务的执行**

  通常情况下，当前宏任务中的JS快执行完成时，也就是**在JS引擎准备退出全局执行上下文并清空调用栈时，JS引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务**。如果在执行过程中产生了新的微任务，也会将该微任务添加到微任务队列中，V8引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。**执行微任务过程中产生新的微任务并不会推迟到下个宏任务中执行，而是在当前宏任务中继续执行**

  *微任务也有其他检查点，但不太重要，故此处不做介绍



## 微任务与宏任务的关系

- 微任务和宏任务是绑定的，每个宏任务在执行时会创建自己的微任务队列
- 微任务执行时长会影响到当前宏任务的时长
- 在一个宏任务中分别创建一个用于回调的宏任务和微任务，无论什么情况下微任务都早于宏任务执行



## 监听DOM变化方法演变

1. **轮询检测**

   早期页面没有提供对监听的支持，比如使用setTimeout或者setInterval来定时检测DOM是否改变

   - **缺点**
     - 时间间隔设置过长，DOM变化响应不够及时
     - 时间间隔设置过短，会浪费很多无用的工作量去检查DOM，会让页面变得低效

2. **观察者的设计模式**

   2000年时引入了Mutation Event，当DOM有变动时就会立刻触发相应的事件，这种方式属于同步回调

   - **缺点**

     DOM一旦发生变化立即调用JS接口，这种实时性造成严重的性能问题，每次变动渲染引擎都会调用JS会产生较大的性能开销和时间开销，造成页面性能问题

   *Mutation Event被反对使用并逐步从Web标准事件中删除

3. **MutationObserver**

   - 采用了**“异步+微任务”**策略

     - **异步调用解决同步操作的性能问题**

       MutationObserver将响应函数改成异步调用，可以不用在每次DOM变化时都触发异步调用，而是等多次DOM变化后一次触发异步调用，并且会使用一个数据结构来记录这期间所有DOM的变化

     - **微任务解决实时性的问题**

       每次DOM节点发生变化时，渲染引擎将变化记录封装成微任务并添加进当前微任务队列中，当执行到检查点（执行微任务时间点）时，V8引擎会按照顺序执行微任务

   



