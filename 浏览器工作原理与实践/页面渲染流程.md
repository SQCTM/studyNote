# 页面渲染流程

[TOC]

## 渲染模块

HTML、CSS、JS数据通过渲染模块的处理最终**输出为屏幕上的像素**



## 渲染流水线

由于渲染机制过于复杂，渲染模块被划分为很多子阶段，输入的数据通过这些子阶段最后输出像素，这样的一个处理流程叫做**渲染流水线**

*每个子阶段都有其**输入内容**、**处理过程**和**输出内容**

1. **构建DOM树**

   因为浏览器无法直接理解和使用HTML，所以需要将HTML转换为浏览器能够理解的DOM树结构

2. **样式计算**

   1. **把CSS转换为浏览器能够理解的结构**

      浏览器无法直接理解纯文本的CSS样式，当渲染引擎接收到CSS文本时会将其转换为浏览器可以理解的**styleSheets**结构，该结构具备查询和修改功能

   2. **转换样式表中属性值使其标准化**

      将样式表中所有属性的值转换为渲染引擎容易理解的、标准化的计算值

   3. **计算DOM树中每个节点的具体样式**

      计算过程遵守CSS的继承和层叠规则，最终输出的内容是每个DOM节点的样式，并被保存在ComputedStyle结构内

3. **布局阶段**

   计算DOM树中可见元素的几何位置

   1. **创建布局树**

      **只包含可见元素**。遍历DOM树中所有可见节点并加到布局树中，而不可见节点全都忽略（包括head标签下面全部内容）

   2. **布局计算**

      计算布局树节点的坐标位置。布局运算结果会重新写回布局树中，所以布局树既是输入内容也是输出内容，没有清晰地区分开，因此布局阶段这一点不合理

4. **分层**

   渲染引擎需要为特定的节点生成专用的图层，并生成一棵对应的**图层树**。浏览器的页面被分成很多图层，这些图层叠加后合成了最终的页面

   *通常情况下不是布局树的每个节点都包含一个图层，如果一个节点没有对应图层则这个节点就从属于父节点的图层

   - **元素被提升为一个单独图层的条件**
     - 拥有**层叠上下文属性**，如明确定位属性、透明度、CSS滤镜(filter)、z-index等
     - 需要**剪裁**(clip)的元素。例如一个div的长宽被限定，而div中文字内容较多显示区域超出div面积，这时会发生剪裁，渲染引擎为文字部分单独创建一个层；如果出现滚动条，滚动条也会被提升为单独的层

5. **图层绘制**

   渲染引擎会把一个图层的绘制拆分成很多小的**绘制指令**，然后把这些指令按照顺序组成一个**待绘制列表**。每个元素的背景、前景、边框都需要单独的指令去绘制

6. **分块**

   实际绘制操作是由渲染引擎中的**合成线程**来完成。渲染主线程把绘制列表提交给合成线程，合成线程将图层划分为**图块**

   - **分块原因**

     通常一个页面很大，用户只能看到其中一个部分，即**视口**。绘制所有图层会产生太大开销，没有必要

7. **光栅化**

   即**将图块转换为位图**。合成线程按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的

   - **光栅化线程池**

     图块是栅格化执行的最小单位，渲染进程维护了一个栅格化的线程池，所有图块的栅格化都是在线程池内执行

   - **GPU加速**

     通常栅格化过程都会**使用GPU来加速生成**，使用GPU生成位图的过程叫快速栅格化或GPU栅格化，生成的位图**被保存在GPU内存中**

     *GPU操作是运行在GPU进程中的，所以这涉及到**跨进程操作**

8. **合成和显示**

   所有图块光栅化完成，合成线程会生成一个**绘制图块的命令"DrawQuad"**，然后将命令提交给浏览器进程。浏览器进程中的**viz组件**接收到命令后根据命令**将页面内容绘制到内存中**，最后再**将内存显示在屏幕上**



## 相关概念

- **重排**

  如果修改元素的**几何位置属性**，浏览器会触发重新布局，执行之后一系列子阶段进行重排

  *重排需要更新完整的渲染流水线，开销最大

- **重绘**

  如果修改元素的**绘制属性**，浏览器就不会执行布局阶段，而是**直接进入绘制阶段**并执行之后一系列子阶段进行重绘

  *重绘省去布局和分层阶段，执行效率比重排操作高

- **直接合成**

  如果更改一个既不要布局也不要绘制的属性，渲染引擎将跳过布局和绘制只执行后续的合成操作

  如使用CSS的transform来实现动画效果可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作，没有占用主线程的资源，也避开了布局和绘制两个子阶段，因此合成大大提升了绘制效率