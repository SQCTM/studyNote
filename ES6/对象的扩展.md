# 对象的扩展

[TOC]

## 属性的可枚举性

- **描述对象**

  对象的每个属性都有一个描述对象用来控制该属性的行为，`Object.getOwnPropertyDescriptor(obj, foo)`方法可以获取该属性的描述对象

- **enumerable属性**

  描述对象中的属性，称为**“可枚举性”**，如果该属性为false就表示某些操作会忽略当前属性

- **忽略不可枚举的属性的操作**

  - `for...in`循环：只遍历对象**自身的**和**继承的**可枚举的属性
  - `Object.keys()`：返回对象自身的所有可枚举的属性的键名
  - `JSON.stringify()`：只串行化对象自身的可枚举的属性
  - `Object.assign()`： ES6新增，会忽略`enumerable`为`false`的属性，只拷贝对象自身的可枚举的属性



## 属性的遍历

- **遍历方法**

  一共有五种方法可以遍历对象属性

  - `for...in`循环：只遍历对象**自身的**和**继承的**可枚举的属性（不含Symbol属性）
  - `Object.keys(obj)`：返回一个数组，包括对象自身的所有可枚举属性的键名（不含Symbol属性）
  - `Object.getOwnPropertyNames(obj)`：返回一个数组，包含对象自身的所有属性的键名（不含Symbol属性，但包括不可枚举属性）
  - `Object.getOwnPropertySymbols(obj)`：返回一个数组，包含对象自身的所有Symbol属性的键名
  - `Reflect.ownKeys(obj)`：返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举

- **属性遍历次序规则**

  1. 首先遍历所有**数值键**，按照**数值升序**排列
  2. 其次遍历所有**字符串键**，按照**加入时间升序**排列
  3. 最后遍历所有**Symbol键**，按照**加入时间升序**排列



## 新增方法

- **Object.is()**

  用来**比较**两个值是否严格相等，在所有环境中只要两个值是一样的该方法就判定为相等，与严格比较运算符（`===`）的行为基本一致

  - **与严格比较运算符区别**

    - `+0`不等于`-0``
    - `NaN`等于自身

    ```javascript
    +0 === -0 //true
    NaN === NaN // false
    
    Object.is(+0, -0) // false
    Object.is(NaN, NaN) // true
    ```

- **Object.assign()**

  用于**对象的合并**，将源对象（source）的所有可枚举属性，复制到目标对象（target）

  ```javascript
  //第一个参数是目标对象，后面的参数都是源对象
  const target = { a: 1 };
  const source1 = { b: 2 };
  const source2 = { c: 3 };
  Object.assign(target, source1, source2);
  target // {a:1, b:2, c:3}
  
  //如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性
  const target = { a: 1, b: 1 };
  const source1 = { b: 2, c: 2 };
  const source2 = { c: 3 };
  Object.assign(target, source1, source2);
  target // {a:1, b:2, c:3}
  
  //如果只有一个参数会直接返回该参数
  const obj = {a: 1};
  Object.assign(obj) === obj // true
  
  //如果参数不是对象，则会先转成对象，然后返回
  typeof Object.assign(2) // "object"
  
  /*
    undefined和null无法转成对象，所以它们作为第一个参数会报错
    但如果非对象参数出现在源对象的位置（即非首参），则这些参数都会转成对象，如果无法转成对象就会跳过
    所以如果undefined和null不在首参数，就不会报错
    这是因为只有字符串的包装对象，会产生可枚举属性
  */
  Object.assign(undefined)  // 报错
  Object.assign(null)  // 报错
  let obj = {a: 1};
  Object.assign(obj, undefined) === obj // true
  Object.assign(obj, null) === obj // true
  
  /*
    其他类型的值（即数值、字符串和布尔值）不在首参数也不会报错
    除了字符串会以数组形式拷贝入目标对象，其他值都不会产生效果
  */
  const v1 = 'abc';
  const v2 = true;
  const v3 = 10;
  const obj = Object.assign({}, v1, v2, v3);
  console.log(obj); // { "0": "a", "1": "b", "2": "c" }
  ```

  - **注意点**

    - `Object.assign()`复制的属性是**有限制**的，只拷贝源对象的自身属性，不复制不可枚举的属性（`enumerable: false`）和继承属性

    - `Object.assign()`方法实行的是**浅拷贝**，如果源对象某个属性值是对象，则目标对象拷贝得到的是这个对象的引用，这个对象的任何变化，都会反映到目标对象上面

      ```javascript
      const obj1 = {a: {b: 1}};
      const obj2 = Object.assign({}, obj1);
      
      obj1.a.b = 2;
      obj2.a.b // 2
      ```

    - 可以用来**处理数组**，但是会**把数组视为对象**

      ```javascript
      Object.assign([1, 2, 3], [4, 5])  // [4, 5, 3]
      //上面代码中方法把数组视为属性名为0、1、2的对象，因此源数组的0号属性4覆盖了目标数组的0号属性1
      ```

    - **取值函数的处理**

      `Object.assign()`只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制

      ```javascript
      const source = {
        get foo() { return 1 }
      };
      const target = {};
      
      Object.assign(target, source)
      // { foo: 1 }
      ```

  - **用途**

    - **为对象添加属性**

      ```javascript
      class Point {
        constructor(x, y) {
          Object.assign(this, {x, y});
        }
      }
      //上面方法通过Object.assign()方法，将x属性和y属性添加到Point类的对象实例
      ```

    - **为对象添加方法**

      ```javascript
      Object.assign(SomeClass.prototype, {
        someMethod(arg1, arg2) {
          ···
        },
        anotherMethod() {
          ···
        }
      });
      
      // 等同于下面的写法
      SomeClass.prototype.someMethod = function (arg1, arg2) {
        ···
      };
      SomeClass.prototype.anotherMethod = function () {
        ···
      };
      ```

    - **克隆对象**

      ```javascript
      function clone(origin) {
        return Object.assign({}, origin);
      }
      //采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值
      //如果想要保持继承链，可以采用下面的代码
      function clone(origin) {
        let originProto = Object.getPrototypeOf(origin);
        return Object.assign(Object.create(originProto), origin);
      }
      ```

    - **为属性指定默认值**

      ```javascript
      const DEFAULTS = {
        logLevel: 0,
        outputFormat: 'html'
      };
      
      function processContent(options) {
        options = Object.assign({}, DEFAULTS, options);
        console.log(options);
        // ...
      }
      //DEFAULTS对象是默认值，options对象是用户提供的参数
      //由于存在浅拷贝的问题，DEFAULTS对象和options对象的所有属性的值最好都是简单类型，不要指向另一个对象。否则DEFAULTS对象的该属性很可能不起作用
      ```



## 对象的扩展运算符

扩展运算符（`...`）



## Null传导运算符

