# js零碎知识点

[TOC]



## 基本概念

- **js组成**

  - ECMAScript
  - DOM文档对象模型
  - BOM浏览器对象模型

- **ECMAScript与JavaScript关系**

  ECMAScript 是 JavaScript 的规范，JavaScript 实现了 ECMAScript

  

## 数据类型

- **5+1种**

   **5种简单**数据类型：Undefined、Null、Boolean、Number、String；**1种复杂**数据类型：Object

- **检测数据类型**

  - `instanceof` 用于检测引用类型；`typeof` 无法精准检测引用类型，适合检测基本数据类型

  - `typeof`

    一元操作符，所有返回值都是**字符串**

    ```js
    //操作null返回"object"
    console.log(typeof null);  //"object"
    ```

  - `instanceof`

    二元操作符

    - 检测一个**引用类型值**和**Object**构造函数时，返回值永远是`true`，因为**所有引用类型值都是Object的实例**

    - 检测任何**基本类型值**，返回结果永远是`false`，因为基本类型不是对象

      ```js
      12 instanceof Number   //false
      ```

- **null和undefined**

  - `undefined`本质是window对象的一个属性

  - `null` 和 `undefined` 转化为数字：

    - `null` → 0
    - `undefined` → `NaN`

  - `undefined` 值是派生自 `null` 值

    ```javascript
    console.log(null == undefined);   //true
    console.log(null === undefined);   //false
    ```

- 只有6种数据会转化成`false`：**undefined、null、零、负零、NaN、空字符串**；其余数据值都转化成`true`，包括空对象

- **浮点数**

  - 保存浮点数值所需内存空间是整数值的两倍，若**小数点后没有数字**或**浮点数值本身表示一个整数**（如1.0），则该浮点值会**被转换为整数**
  - 0.1加0.2结果不等于0.3；因为数据从十进制→二进制→十进制这个过程产生了误差

- **无穷**

  - Number类型整数范围为 **-2<sup>53</sup>~2<sup>53</sup>**，超出范围会被转化为 **-Infinity**（负无穷）或 **Infinity**（正无穷），`Infinity`无法参与运算
  - **除法**`\`
    - 正数除以0返回`Infinity`；
    - 负数除以0返回`-Infinity`；
    - 0/0返回`NaN`；
    - `Infinity/Infinity`结果是 `NaN`；
    - `Infinity/非0数值`结果是 `Infinity` 或 `-Infinity`
  - **乘法**`*`
    - `Infinity*0`结果是`NaN`；
    - `Infinity*非0数值`结果是`Infinity`或`-Infinity`；
    - `Infinity*Infinity`结果是`Infinity`
  - **减法**`-`
    - `Infinity - Infinity`结果`NaN`；
    - `-Infinity - -Infinity`结果是`NaN`；
    - `Infinity - -Infinity`结果是 `Infinity`；
    - `-Infinity - Infinity`结果是`-Infinity`
  - **加法**`+`
    - `Infinity + Infinity`结果是 `Infinity`；
    - `-Infinity + -Infinity`结果是`-Infinity`；
    -  `Infinity + -Infinity`结果是 `NaN`

- **NaN**

  - 任何涉及`NaN`的运算都会返回`NaN`

  - NaN与任何值都不相等，包括NaN本身

    ```javascript
    console.log(NaN == NaN);   //false
    ```

  - **isNaN()**函数判断传入的值是否**不能被转化成数字**

- **parseInt()**会将空字符串会转换成`NaN`，如果第一个字符是数字则会继续解析下去直至遇到非数字字符（包括小数点

- **parseFloat()**可以解析第一个小数点，但只能解析十进制值，十六进制值被转化为0

- String字符串是**不可变的**。字符串一旦创建，它的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量

- `Number()`转化对象，调用对象的`valueOf()`方法依据规则转换，若转换结果为`NaN`则调用对象的`toString()`方法再依据规则转换；

  `toString()`转化对象，调用对象的`toString()`方法依据规则转换，若转换结果为`NaN`则调用对象的`valueOf()`方法再依据规则转换

- 基本数据类型没有属性和方法，只有引用类型有。基本数据类型方法是**先转化成对象再调用**（`undefined`和`null`不能）



## 操作符

- `++num`与`num++`的区别

  运算时，前置型会使用递加后的num值；后置型会先使用num的原始值，然后num自身再递加

  ```javascript
  //1.
  var a = 1;
  var b = a++ + a;  //3
  //a = 2
  
  //2.
  var a = 1;
  var b = a++ + ++a; //4
  //a = 3
  ```

- 一元加和一元减放在非数值前，会等同于`Number()`将非数值转化为数值

- 一元操作符**按位非** `~` 本质是将**操作数的负值减 1**

- 同时使用两个逻辑非操作符`!!`会模拟**Boolean()**转型函数的行为，将操作数转化为布尔值

- **逻辑与/或**

  - 都是**短路操作**，如果第一个操作数能决定结果则直接返回第一个操作数，否则对第二个操作数求值并返回
  - 逻辑与`&&`优先级高于逻辑或`||`

- **关系操作符**

  即`<`、`>`、`<=`和`>=`

  - 如果两个操作数都是字符串，则比较两个字符串对应的**字符编码值**，比较时必须**转换为相同的大小写形式**（全部大写或小写）
  - 比较数值与字符串时，会**将字符串转换为数值**
  - 任何操作数与`NaN`进行任何比较结果都是`false`

- `+0`与`-0`的运算

  - `+0 - +0`结果是`+0`；`+0 - -0`结果是`-0`；`-0 - -0`结果是`+0`
  - `+0 + +0`结果是`+0`；`-0 + -0`结果是`-0`；`+0 + -0`结果是`+0`



## 变量

- 是**松散类型**的，即可以用来保存任何类型的数据

- **定义变量**

  - 使用var定义——局部变量
  - 省略var定义——全局变量（不推荐

- **保存数据类型**

  - **基本类型值**

    **按值访问**，可以操作保存在变量中的实际值，被保存在**栈内存**中

  - **引用类型值**

    **对象**。值保存在**堆内存**中，不能直接操作对象的内存空间。

    当复制保存着对象的某个变量时，操作的是对象的引用；在为对象添加属性时，操作的是实际的对象

- **创建变量**

  1. 创建命名
  2. 创建作用范围（作用域）
  3. 将创建变量的过程提至函数最顶部

- **给变量赋值**

  - 基本类型值被保存在变量中
  - 引用类型值被保存在内存中，同时创建内存地址即引用，然后将引用保存到创建出来的变量中

- **修改变量**

  - 先将原变量销毁，再重新创建赋值
  - 修改引用类型值的某个属性，则是解析器根据变量中保存的地址，在内存中找到保存的对象，再进行修改

- **复制变量**

  - 若是基本类型值，两个变量完全**独立**，参与任何操作**互不影响**
  - 若是引用类型值，复制的只是变量的地址，两个变量实际上将**引用同一个对象**。虽然两个变量相互独立，但改变其中一个变量就会影响另一个变量

- **传递参数**

  - 所有函数的参数都是**按值传递的**

  - 解析器不关心函数参数的数据类型

  - **引用类型的参数**也是**按值传递**，而不是按引用传递

    ```js
    function setName(obj) {     
        obj.name = "Nicholas";     
        obj = new Object();  //局部对象，在函数执行完毕后立即被销毁   
        obj.name = "Greg"; 
    } 
    var person = new Object(); 
    setName(person); 
    console.log(person.name);    //"Nicholas" 
    ```

    

## 引用类型

- **对象Object**

  - 对象的属性为数值的话会被自动转换为字符串

  - **获取对象属性值方法**

    ```js
    //1.用变量访问或属性名中包含特殊字符
    alert(person["name"]);    
    //2.通常用这个
    alert(person.name);
    ```

- **数组Array**

  - 数组每一项可以保存任何类型的数据

  - 数组的大小可以动态调整，可以通过设置数组的`length`属性调整

  - **sort()排序方法**

    调用每个数组项的`toString()`转型方法，然后比较得到的字符串；**默认情况下按升序排列**数组项

    - **接收一个比较函数作为参数**

      ```js
      //升序
      function compare(value1, value2){     
          return value1 - value2; 
      } 
      
      //降序
      function compare(value1, value2){     
          return value2 - value1; 
      } 
      ```

  - **join()方法**

    把数组所有元素**转换成字符串**并**用指定分隔符连接**，若不传参则**默认是逗号**

  - **concat()方法**

    创建当前数组的一个副本，然后将接收的参数添加到副本的末尾，最后**返回新构建的数组**；若没有传参则只是复制当前数组并返回副本

  - **slice()方法**

    从已有数组中**返回选定的元素**，返回的是一个**新的数组**

    - 一个参数，返回从参数指定位置开始到当前数组末尾的所有项
    - 两个参数，返回起始位置开始到结束位置之间的项（**不包括结束位置的项**）
    - 不传参，返回数组副本
    - 参数为负数，**加上数组长度来取值**，相当于倒着取
    - 参数超出范围或第一个参数比第二个参数大，则**返回空数组**

  - **splice()方法**

    向/从数组中添加/删除项目，然后返回被删除的项目

    - **删除**

      参数为**要删除部分的开始位置**和**要删除的项数**

    - **插入/替换**

      参数有三个，为**起始位置**、**要删除的项数**(0就是插入，非0就是替换)、**要插入的项**

      替换时插入的项数不必与删除的项数相等

  - **迭代方法**

    一共有五种方法，每种都**接收两个参数**：

    - 在数组**每一项上运行的函数**
    - 运行该函数的作用域对象（可选，影响this值)

    **第一个参数即运行的函数接收三个参数**：

    - 数组项的值`item`
    - 该项在数组中的位置`index`
    - 数组对象本身`arr`

    **五个方法**：

    - `every()`：如果传入函数对**每一项**都返回true，则返回true
    - `filter()`：返回对传入函数**会返回true的项组成的数组**
    - `forEach()`：没有返回值
    - `map()`：返回每次传入函数调用的**结果组成的数组**
    - `some()`：如果传入函数对**任意一项**返回true，则返回true

  - **归并方法**

    一共有两种方法，每种都会**迭代数组所有项**：

    - `reduce()`：从数组第一项开始逐个遍历到最后
    - `reduceRight()`：从数组的最后一项开始向前遍历到第一项

    每种方法都接收**两个参数**：

    - 在数组**每一项上运行的函数**
    - 作为归并基础的**初始值**（可选）

    **第一个参数即运行的函数接收四个参数**：

    - 前一个值`prev`
    - 当前值`cur`
    - 项的索引`index`
    - 数组对象本身`arr`

    此函数**返回的任何值都会作为第一个参数自动传给下一项**

  - **数组去重的特殊方法**

    - **利用对象属性特性**

      创建一个空对象和空数组，遍历要去重的数组，判断对象的属性中是否有被选中的项，如果没有就将它加入空数组并设为对象的一个属性名且赋值为`true`或 1，否则跳过

    - **set对象**

      ```javascript
      var arr = [1,1,2,3,4,4,4];
      var set = new Set(arr);   //自动去重 set对象中不会有重复的项
      arr = Array.from(set);   //将set对象转换成数组
      //或者使用扩展运算符也可以
      arr = [...new Set(arr)];  
      ```

      

      