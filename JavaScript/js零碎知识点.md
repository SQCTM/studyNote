# js零碎知识点

[TOC]

## 基本概念

- **js组成**

  - ECMAScript
  - DOM文档对象模型
  - BOM浏览器对象模型

- **ECMAScript与JavaScript关系**

  ECMAScript 是 JavaScript 的规范，JavaScript 实现了 ECMAScript

  

## 数据类型

**5+1种**：**5种简单**数据类型：Undefined、Null、Boolean、Number、String；**1种复杂**数据类型：Object

- **检测数据类型**

  - `instanceof` 用于检测引用类型；`typeof` 无法精准检测引用类型，适合检测基本数据类型

  - `typeof`

    一元操作符，所有返回值都是**字符串**

    ```js
    //操作null返回"object"
    console.log(typeof null);  //"object"
    ```

  - `instanceof`

    二元操作符

    - 检测一个**引用类型值**和**Object**构造函数时，返回值永远是`true`，因为**所有引用类型值都是Object的实例**

    - 检测任何**基本类型值**，返回结果永远是`false`，因为基本类型不是对象

      ```js
      12 instanceof Number   //false
      ```

- **null和undefined**

  - `undefined`本质是window对象的一个属性

  - `null` 和 `undefined` 转化为数字：

    - `null` → 0
    - `undefined` → `NaN`

  - `undefined` 值是派生自 `null` 值

    ```javascript
    console.log(null == undefined);   //true
    console.log(null === undefined);   //false
    ```

- 只有6种数据会转化成`false`：**undefined、null、零、负零、NaN、空字符串**；其余数据值都转化成`true`，包括空对象

- **浮点数**

  - 保存浮点数值所需内存空间是整数值的两倍，若**小数点后没有数字**或**浮点数值本身表示一个整数**（如1.0），则该浮点值会**被转换为整数**
  - 0.1加0.2结果不等于0.3；因为数据从十进制→二进制→十进制这个过程产生了误差

- **无穷**

  - Number类型整数范围为 **-2<sup>53</sup>~2<sup>53</sup>**，超出范围会被转化为 **-Infinity**（负无穷）或 **Infinity**（正无穷），`Infinity`无法参与运算
  - **除法**`\`
    - 正数除以0返回`Infinity`；
    - 负数除以0返回`-Infinity`；
    - 0/0返回`NaN`；
    - `Infinity/Infinity`结果是 `NaN`；
    - `Infinity/非0数值`结果是 `Infinity` 或 `-Infinity`
  - **乘法**`*`
    - `Infinity*0`结果是`NaN`；
    - `Infinity*非0数值`结果是`Infinity`或`-Infinity`；
    - `Infinity*Infinity`结果是`Infinity`
  - **减法**`-`
    - `Infinity - Infinity`结果`NaN`；
    - `-Infinity - -Infinity`结果是`NaN`；
    - `Infinity - -Infinity`结果是 `Infinity`；
    - `-Infinity - Infinity`结果是`-Infinity`
  - **加法**`+`
    - `Infinity + Infinity`结果是 `Infinity`；
    - `-Infinity + -Infinity`结果是`-Infinity`；
    -  `Infinity + -Infinity`结果是 `NaN`

- **NaN**

  - 任何涉及`NaN`的运算都会返回`NaN`

  - NaN与任何值都不相等，包括NaN本身

    ```javascript
    console.log(NaN == NaN);   //false
    ```

  - **isNaN()**函数判断传入的值是否**不能被转化成数字**

- `parseInt()`会将空字符串会转换成`NaN`，如果第一个字符是数字则会继续解析下去直至遇到非数字字符（包括小数点

- `parseFloat()`可以解析第一个小数点，但只能解析十进制值，十六进制值被转化为0

- String字符串是**不可变的**。字符串一旦创建，它的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量

- `Number()`转化对象，调用对象的`valueOf()`方法依据规则转换，若转换结果为`NaN`则调用对象的`toString()`方法再依据规则转换；

  `toString()`转化对象，调用对象的`toString()`方法依据规则转换，若转换结果为`NaN`则调用对象的`valueOf()`方法再依据规则转换

- 基本数据类型没有属性和方法，只有引用类型有。基本数据类型方法是**先转化成对象再调用**（`undefined`和`null`不能）



## 操作符

- `++num`与`num++`的区别

  运算时，前置型会使用递加后的num值；后置型会先使用num的原始值，然后num自身再递加

  ```javascript
  //1.
  var a = 1;
  var b = a++ + a;  //3
  //a = 2
  
  //2.
  var a = 1;
  var b = a++ + ++a; //4
  //a = 3
  ```

- 一元加和一元减放在非数值前，会等同于`Number()`将非数值转化为数值

- 一元操作符**按位非** `~` 本质是将**操作数的负值减 1**

- 同时使用两个逻辑非操作符`!!`会模拟`Boolean()`转型函数的行为，将操作数转化为布尔值

- **逻辑与/或**

  - 都是**短路操作**，如果第一个操作数能决定结果则直接返回第一个操作数，否则对第二个操作数求值并返回
  - 逻辑与`&&`优先级高于逻辑或`||`

- **关系操作符**

  即`<`、`>`、`<=`和`>=`

  - 如果两个操作数都是字符串，则比较两个字符串对应的**字符编码值**，比较时必须**转换为相同的大小写形式**（全部大写或小写）
  - 比较数值与字符串时，会**将字符串转换为数值**
  - 任何操作数与`NaN`进行任何比较结果都是`false`

- `+0`与`-0`的运算

  - `+0 - +0`结果是`+0`；`+0 - -0`结果是`-0`；`-0 - -0`结果是`+0`
  - `+0 + +0`结果是`+0`；`-0 + -0`结果是`-0`；`+0 + -0`结果是`+0`



## 变量

- 是**松散类型**的，即可以用来保存任何类型的数据

- **定义变量**

  - 使用var定义——局部变量
  - 省略var定义——全局变量（不推荐

- **保存数据类型**

  - **基本类型值**

    **按值访问**，可以操作保存在变量中的实际值，被保存在**栈内存**中

  - **引用类型值**

    **对象**。值保存在**堆内存**中，不能直接操作对象的内存空间。

    当复制保存着对象的某个变量时，操作的是对象的引用；在为对象添加属性时，操作的是实际的对象

- **创建变量**

  1. 创建命名
  2. 创建作用范围（作用域）
  3. 将创建变量的过程提至函数最顶部

- **给变量赋值**

  - 基本类型值被保存在变量中
  - 引用类型值被保存在内存中，同时创建内存地址即引用，然后将引用保存到创建出来的变量中

- **修改变量**

  - 先将原变量销毁，再重新创建赋值
  - 修改引用类型值的某个属性，则是解析器根据变量中保存的地址，在内存中找到保存的对象，再进行修改

- **复制变量**

  - 若是基本类型值，两个变量完全**独立**，参与任何操作**互不影响**
  - 若是引用类型值，复制的只是变量的地址，两个变量实际上将**引用同一个对象**。虽然两个变量相互独立，但改变其中一个变量就会影响另一个变量

- **传递参数**

  - 所有函数的参数都是**按值传递的**

  - 解析器不关心函数参数的数据类型

  - **引用类型的参数**也是**按值传递**，而不是按引用传递

    ```js
    function setName(obj) {     
        obj.name = "Nicholas";     
        obj = new Object();  //局部对象，在函数执行完毕后立即被销毁   
        obj.name = "Greg"; 
    } 
    var person = new Object(); 
    setName(person); 
    console.log(person.name);    //"Nicholas" 
    ```

    

## 引用类型

Date类型和RegExp类型略

### 对象Object

- 对象的属性为数值的话会被自动转换为字符串

- **获取对象属性值方法**

  ```js
  //1.用变量访问或属性名中包含特殊字符
  alert(person["name"]);    
  //2.通常用这个
  alert(person.name);
  ```



### 数组Array

- 数组每一项可以保存任何类型的数据

- 数组的大小可以动态调整，可以通过设置数组的`length`属性调整

- **sort()排序方法**

  调用每个数组项的`toString()`转型方法，然后比较得到的字符串；**默认情况下按升序排列**数组项

  - **接收一个比较函数作为参数**

    ```js
    //升序
    function compare(value1, value2){     
        return value1 - value2; 
    } 
    
    //降序
    function compare(value1, value2){     
        return value2 - value1; 
    } 
    ```

- **join()方法**

  把数组所有元素**转换成字符串**并**用指定分隔符连接**，若不传参则**默认是逗号**

- **concat()方法**

  创建当前数组的一个副本，然后将接收的参数添加到副本的末尾，最后**返回新构建的数组**；若没有传参则只是复制当前数组并返回副本

- **slice()方法**

  从已有数组中**返回选定的元素**，返回的是一个**新的数组**

  - 一个参数，返回从参数指定位置开始到当前数组末尾的所有项
  - 两个参数，返回起始位置开始到结束位置之间的项（**不包括结束位置的项**）
  - 不传参，返回数组副本
  - 参数为负数，**加上数组长度来取值**，相当于倒着取
  - 参数超出范围或第一个参数比第二个参数大，则**返回空数组**

- **splice()方法**

  向/从数组中添加/删除项目，然后返回被删除的项目

  - **删除**

    参数为**要删除部分的开始位置**和**要删除的项数**

  - **插入/替换**

    参数有三个，为**起始位置**、**要删除的项数**(0就是插入，非0就是替换)、**要插入的项**

    替换时插入的项数不必与删除的项数相等

- **迭代方法**

  一共有五种方法，每种都**接收两个参数**：

  - 在数组**每一项上运行的函数**
  - 运行该函数的作用域对象（可选，影响this值)

  **第一个参数即运行的函数接收三个参数**：

  - 数组项的值`item`
  - 该项在数组中的位置`index`
  - 数组对象本身`arr`

  **五个方法**：

  - `every()`：如果传入函数对**每一项**都返回true，则返回true
  - `filter()`：返回对传入函数**会返回true的项组成的数组**
  - `forEach()`：没有返回值
  - `map()`：返回每次传入函数调用的**结果组成的数组**
  - `some()`：如果传入函数对**任意一项**返回true，则返回true

- **归并方法**

  一共有两种方法，每种都会**迭代数组所有项**：

  - `reduce()`：从数组第一项开始逐个遍历到最后
  - `reduceRight()`：从数组的最后一项开始向前遍历到第一项

  每种方法都接收**两个参数**：

  - 在数组**每一项上运行的函数**
  - 作为归并基础的**初始值**（可选）

  **第一个参数即运行的函数接收四个参数**：

  - 前一个值`prev`
  - 当前值`cur`
  - 项的索引`index`
  - 数组对象本身`arr`

  此函数**返回的任何值都会作为第一个参数自动传给下一项**

- **数组去重的特殊方法**

  - **利用对象属性特性**

    创建一个空对象和空数组，遍历要去重的数组，判断对象的属性中是否有被选中的项，如果没有就将它加入空数组并设为对象的一个属性名且赋值为`true`或 1，否则跳过

  - **set对象**

    ```javascript
    var arr = [1,1,2,3,4,4,4];
    var set = new Set(arr);   //自动去重 set对象中不会有重复的项
    arr = Array.from(set);   //将set对象转换成数组
    //或者使用扩展运算符也可以
    arr = [...new Set(arr)];  
    ```



### Function类型

- **创建函数**

  - **声明语句**

    ```js
    function sum (num1, num2) {     
        return num1 + num2; 
    }
    ```

    最好不要在语句块中使用

  - **表达式语句**

    ```js
    //创建匿名函数
    var sum = function(num1, num2){     
        return num1 + num2; 
    };
    
    //创建命名函数
    var result = (function sum(num1, num2){
        return num1+num2;
    })
    ```

    - 命名函数有`name`属性，值即为函数名的字符串；匿名函数`name`属性为`undefined`
    - **函数名是一个指向函数对象的指针**，用表达式语句创建的命名函数**可在函数内部调用函数名**，但**不能在函数外部调用**（声明语句创建的函数内部外部都可以调用）

  - **箭头函数(ES6)**

    - 是**匿名函数**，`name`属性值为**空字符串**
    - 不会创建上下文执行环境
    - 没有`arguments`对象，没有自己的`this`

  - **函数生成器(ES6)**

    `function*`，可以**保存函数执行状态**，`yield`返回的**迭代器对象**：

    - 有`next()`方法，每次调用从当前`yield`开始执行至下一个`yield`或函数结束
    - 有两个属性：`value`即返回值；`done`是判断是否执行至最后一个`yield`

  - **函数构造器**

    `new Function()`；不推荐，因为数据的安全性和函数的性能有很大问题，而且只在全局作用域下创建易命名污染

- **函数内部属性**

  - `arguments`

    - 类数组对象，包含传入函数中的**所有参数**
    - 有一个`callee`属性，指向拥有这个 `arguments` 对象的**函数**（严格模式下访问这个属性会报错）

  - `this`

    引用的是函数执行的**环境对象**

  - `caller`

    保存着**调用当前函数的函数的引用**， 如果是在全局作用域中调用当前函数，它的值为`null`

- **函数属性**

  - `length`：函数形参个数
  - `prototype`：保存引用类型所有实例方法的真正所在

- **函数方法**

  - `apply()`和`call()`

    非继承，在特定的作用域中调用函数，实际上等于设置函数体内this对象的值

    两个方法作用相同，区别为接收参数方法不同：

    - `apply()`第一个参数为运行函数的作用域，第二个为函数参数数组或`arguments`对象
    - `call()`第一个参数为运行函数的作用域，其它参数是将函数的参数一个一个传入

  - `bind()`

    `this`值被绑定为传给该方法的参数



### 基本包装类型

- **Boolean类型**

  建议永远不使用

- **Number类型**

  - `toFixed()`

    **按照指定的小数位返回数值的字符串表示**，只有一个参数即指定的小数位，超过20位就会报错

  - `toExponential()`

    返回以指数表示法（也称e表示法）表示的数值的字符串形式，只有一个参数即指定的小数位

  - `toPrecision()`

    只有一个参数，即表示数值的**所有数字**的位数

- **String类型**

  - **字符方法**
    - `charAt()`：返回给定位置的**单字符**
    - `charCodeAt()`：返回给定位置的单字符的**字符编码**
  - **字符串操作方法**
    - `concat()`：拼接字符串，但是一般用`+`更加方便
    - `slice()`：与数组的`slice()`方法类似
    - `substr()`：返回子字符串；第一个参数即开始位置，第二个即子字符串长度，若没有第二个参数则到字符串末尾；若参数是负数，第一个负数参数加上字符串长度，第二个转换为0
    - `substring()`：与`slice()`类似，区别是若第一个参数大于第二个参数可以自动调换过来，且若参数是负数则转换为0
  - **字符串位置方法**
    - `indexOf()`从前往后找；`lastIndexOf()`从后往前找
    - 找不到返回 -1
    - 第二个参数可选，即开始查找的位置
  - `trim()`
    - 创建一个字符串副本，**删除前置以及后缀所有空格**，然后返回
    - `trimLeft`只删除前置空格；`trimRight`只删除后缀空格
  - **大小写转换**
    - **所有字母转换成小写**
      - `toLowerCase()`
      - `toLocaleLowerCase()`
    - **所有字母转换成大写**
      - `toUpperCase()`
      - `toLocaleUpperCase()`
  - **模式匹配**
    - `match()`：本质上与调用 RegExp 的`exec()`方法相同
    - `search()`：返回字符串中第一个匹配项的索引；如果没有找到匹配项则返回-1
    - `replace()`：替换。第一个参数是一个 RegExp 对象或者一个字符串（这个字符串不会被转换成正则表达式）；第二个是一个字符串或者一个函数
    - `split()`：基于指定的分隔符将一个字符串分割并变成数组；参数即指定分隔符，若参数为空字符串则每个字符都会被分割



### 单体内置对象

- **Global对象**

  - 所有在全局作用域中定义的属性和函数，都是Global对象的属性
  - Web浏览器是将全局对象作为window对象的一部分实现的。因此在全局作用域中声明的所有变量和函数，都成了window对象的属性
  - `eval()`
    - ES中最强大的一个方法
    - 只接受一个参数，即要执行的 ES（或 JS）字符串
    - 用该方法被执行的代码具有**与该执行环境相同的作用域链**，因此执行的代码**可以引用在包含环境中定义的变量**
    - 在`eval()`执行的代码中**声明的任何变量或函数都不会被提升**，只在`eval()`执行的时候创建

- **Math对象**

  - `max()`和`min()`：找最大值和最小值

  - `Math.ceil()`：向上舍入

  - `Math.floor()`：向下舍入

  - `Math.round()`：标准舍入，即四舍五入

  - `random()`：返回**大于等于0小于1**的一个随机数

    从某个整数范围内随机选择一个值**公式**：

    `值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值) `

    eg： `var num = Math.floor(Math.random() * 9 + 2);   //2~10之间的随机数 `



## BOM浏览器对象模型

- **window对象**

  - **窗口**

    - **获取窗口位置**

      ```js
      //跨浏览器取得窗口左边和上边的位置
      var leftPos = (typeof window.screenLeft == "number") ?                   
          window.screenLeft : window.screenX; 
      var topPos = (typeof window.screenTop == "number") ?                   
          window.screenTop : window.screenY;
      ```

    - **移动**

      - `moveTo()`接收**新位置的x和y坐标值**
      - `moveBy()`接收**在水平和垂直方向上移动的像素数**

    - **获取窗口大小**

      - `innerWidth`、`innerHeight`表示该容器中页面视图区的大小（减去边框宽度）
      - `outerWidth` 和 `outerHeight`返回浏览器窗口本身的尺寸
      - 在Chrome中，四个属性返回相同的值，即视口大小而非浏览器窗口大小

  - **超时调用**`setTimeout()`

    ```js
    setTimeout(function() {      
        alert("Hello world!"); 
    }, 1000); 
    ```

    - 第二个参数表示等待多长时间的**毫秒数**，但经过该时间后指定的代码不一定会执行。因为JS是一个单线程序的解释器，有一个JS任务队列，任务会按照任务添加到队列的顺序执行。这个参数是告诉JS**过了多长时间把当前任务添加到队列中**。如果队列是空的，那么添加的代码会立即执行；否则，它就要等前面的代码执行完了以后再执行
    - 若设置的毫秒数小于10，系统会自动调成10
    - 结果返回一个数值ID，**超时调用ID**，表示超时调用，是计划执行代码的唯一标识符
    - `clearTimeout()`方法**取消尚未执行的超时调用**计划，**将超时调用ID作为参数传入**即可

  - **间歇调用**`setInterval()`

    ```js
    setInterval (function() {      
        alert("Hello world!");  
    }, 10000); 
    ```

    - 若设置的毫秒数小于10，系统会自动调成10
    - 结果返回一个**间歇调用ID**
    - `clearInterval()`方法取消尚未执行的间歇调用，将间歇调用ID作为参数传入即可
    - 若执行代码时间超过间隔时间，执行完后会立马触发下一次执行（累积效应、连续触发），因此建议使用超时调用来实现间歇调用

  - **系统对话框**

    - `alert()`：警告框
    - `confirm()`：确认框
    - `prompt()`：提示框
    - 系统对话框不包含HTML，样式也不由CSS决定
    - 对话框是**阻断式**的，显示这些对话框时代码会停止执行，而关掉对话框后代码又会恢复执行

- **location对象**

  - 提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能
  - 既是window对象的属性，也是document对象的属性
  - **位置操作方法**
    - `assign()`：立即打开新URL并在浏览器的历史记录中生成一条记录
    - `replace()`：接受一个参数即要导航到的URL；结果会导致浏览器位置改变，但**不会在历史记录中生成新记录**
    - `reload()`
      - 重新加载当前显示的页面
      - 不传递参数时，页面就会以有效的方式重新加载，即页面就会从浏览器缓存中重新加载；若传递参数true，则强制从服务器重新加载
      - 位于`reload()`调用之后的代码可能会也可能不会执行，这要取决于网络延迟或系统资源等因素。因此**最好将 reload() 放在代码的后一行**

- **history对象**

  - 保存着用户上网的历史记录，从窗口被打开的那一刻算起

  - `go()`

    在用户的历史记录中任意跳转，可以向后也可以向前；接收一个整数值作为参数即跳转的页数，负数表示向后，正数表示向前

  - `back()`和`forward()`

    ```js
    //后退一页 
    history.back(); 
     
    //前进一页 
    history.forward();
    ```

  - `length`属性

    保存着历史记录的数量。对于加载到窗口、标签页或框架中的第一个页面而言，`history.length` 等于0



## DOM文档对象模型

DOM将HTML或XML文档描绘成一个由多层节点构成的结构

- **Node类型**

  **所有节点类型都继承自Node类型**，因此所有节点类型都共享着相同的基本属性和方法

  - **属性**

    - `nodeType`：表明节点的类型，由12个数值常量来表示

    - `nodeName`：元素的标签名

    - `nodeValue`：节点的值

    - `childNodes`：保存着一个含该节点所有子节点的`NodeList`类数组对象，有`length`属性，是基于DOM结构动态执行查询的结果

      **访问**：`someNode.childNodes[0]` 或 `someNode.childNodes.item(0)`

    - `parentNode`：指向文档树中的父节点

    - `previousSibling`：上一个同胞结点，没有就是`null`

    - `nextSibling`：下一个同胞结点，没有就是`null`

    - `firstChild`：父节点的第一个子节点，没有就是`null`

    - `lastChild`：父节点的最后一个子节点，没有就是`null`

    - `ownerDocument`：指向表示整个文档的文档节点

  - **方法**

    - `hasChildNodes()`：是否含有子节点，有返回`true`，否则返回`false`
    - `appendChild()`：向`childNodes`列表末尾添加一个节点，然后返回新增的节点；如果传到`appendChild()`中的节点已是文档的一部分，则该节点**从原来的位置转移到新位置**，因为任何DOM节点都不能同时出现在文档中的多个位置上
    - `insertBefore()`：把节点放在`childNodes`列表中某个特定的位置上，参数为**要插入的节点**和作为**参照的节点**，插入的节点被插在参照节点的**前一个位置**，结果返回插入的节点
    - `replaceChile()`：替换，接受两个参数：要插入的节点和要被替换的节点
    - `removeChild()`：移除节点，结果返回被移除的节点；被移除的节点仍为文档所有，只是在文档中没有了自己的位置
    - `cloneNode()`：复制节点；接受一个参数为布尔值：`true`为**深复制**，复制节点及其整个子节点树；`false`为**浅复制**，只复制节点本身
    - `nornalize()`：处理文档树中的文本节点，在调用该方法的节点中删除空文本节点，合并相邻的文本节点为一个文本节点

- **Document类型**

  

- **Element类型**

  

- **Text类型**

  