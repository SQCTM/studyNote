# 事件

[TOC]

## 事件流

事件流描述的是从页面中接收事件的顺序

- **事件冒泡**

  事件开始时，由最具体的元素接收，然后逐级向上传播到较为不具体的节点（文档）

  *所有现代浏览器都支持事件冒泡

- **事件捕获**

  不太具体的节点在事件到达预定目标最具体的节点之前捕获它，先接收到事件，而预定目标最后接收到事件

  *虽然规范要求事件从document对象开始传播，但支持的浏览器都是**从window对象开始**捕获事件

- **DOM事件**

  包括三个阶段：

  - **事件捕获阶段**：不涉及事件目标
  - **处于目标阶段**：事件发生
  - **事件冒泡阶段**：对事件做出响应

  *规范明确要求捕获阶段不会涉及事件目标

*事件的传播按HTML结构传播，**不受CSS影响**。因为**事件的绑定是浏览器实现的**，浏览器的解析是按HTML结构解析的，因此即使例如CSS将内节点与外节点的位置改变也不会影响事件的传播



## 事件处理程序

事件是用户或浏览器自身执行的某种动作，响应某个事件的函数就叫事件处理程序或事件侦听器



### HTML事件处理程序

```html
<!-- 第一种 --> 
<input type="button" value="Click Me" onclick="alert('Clicked')" /> 

<!-- 第二种 --> 
<input type="button" value="Click Me" onclick="showMessage()" />
<script type="text/javascript">     
    function showMessage(){            
        alert("Hello world!");     
    } 
</script> 
```

*此方式添加的事件会在事件流的**冒泡阶段**被处理，事件处理程序中的代码在执行时有权访问**全局作用域**中任何代码

- **局部变量**

  - **event**：直接访问事件对象

    `<input type="button" value="Click Me" onclick="alert(event.type)"> `

    `<!-- 输出 "click" --> `

  - **this**：事件的目标元素

    `<input type="button" value="Click Me" onclick="alert(this.value)"> `

    `<!-- 输出 "Click Me" --> `

- **缺点**

  - 有时间差，有时页面已经加载完成，触发元素事件时，包含相应代码的js文件未加载完成，事件执行失败
  - 扩展事件处理程序的作用域链在不同浏览器中会导致不同的结果，而不同浏览器内置js执行器引擎规则不同，访问某些非限定对象成员可能会出问题
  - HTML与js代码紧密耦合，不易修改代码



### DOM0级事件处理程序

将一个函数赋值给一个事件处理程序属性，每个元素（包括 window 和 document）都有自己的事件处理程序属性，这些属性通常全部小写

```JavaScript
var btn = document.getElementById("myBtn"); 
btn.onclick = function(){     
    alert("Clicked"); 
}; 
```

*该方式添加的事件处理程序会在事件流的**冒泡阶段**被处理

- **作用域**

  该方式事件处理程序会在所属元素的作用域内运行。即程序中this引用当前元素

- **删除事件**

  删除事件即直接将事件处理程序属性的值设置为**null**

- **优点**

  解决了HTML事件处理程序的缺点，简单易写，具有跨浏览器的优势

- **缺点**

  一次只能指定一个事件处理程序，指定多个会覆盖



### DOM2级事件处理程序

定义了两个方法：

- **addEventListener()添加事件** 

  - 添加的事件处理程序也是在其依附的元素的作用域中运行，即this引用当前元素

  - 可以添加多个事件，不会覆盖，且按照添加顺序执行

    ```javascript
    var btn = document.getElementById("myBtn"); 
    btn.addEventListener("click", function(){    
        alert(this.id); 
    }, false); 
    btn.addEventListener("click", function(){     
        alert("Hello world!"); 
    }, false); 
    //先显示id再显示Hello world!
    ```

- **removeEventListener()删除**

  - addEventListener()添加的事件只能通过removeEventListener()删除
  - 删除时传入的函数必须和添加时传入的函数是**同一引用**，这说明**添加的匿名函数无法移除**
  - 删除事件在一次删除中，只能删除冒泡或捕获阶段其中一个阶段的事件

- **三个参数**：

  - 处理事件名
  - 事件处理程序的函数
  - 一个布尔值或对象，表示调用程序是在事件冒泡阶段还是捕获阶段
    - **布尔值**：默认为false，false即冒泡阶段，true即捕获阶段
    - **对象**：有三个属性，皆为布尔类型
      - **capture**：false即冒泡阶段，true即捕获阶段
      - **once**：true则该事件只为执行一次，之后触发无效
      - **passive**：true则不阻止浏览器默认行为，能够提升性能
        - 若该属性值为true则再调用阻止浏览器默认行为方法无效
        - 对同一节点指定多个相同事件，若其中有一个该属性为false，该属性都全部无效
        - 对同一节点指定多个不同事件，只有第一个有效该属性值为true的有效，之后的都无效
        - 该属性对部分事件无效，如click

*所有DOM节点都支持这两种方法，这两个方法都同时支持事件冒泡和事件捕获



### IE事件处理程序

定义了两个方法：

- **attachEvent()**

  - 该方式事件处理程序会在**全局作用域**中运行，即this引用的是window对象
  - 可以添加多个事件，但**事件以与添加顺序相反的顺序触发**
  - 该方式添加的事件都会被添加到**冒泡阶段**

- **detachEvent()**

  - 删除attachEvent()添加的事件

  - 删除时传入的函数必须和添加时传入的函数是**同一引用**，这说明**添加的匿名函数无法移除**

    ```javascript
    var btn = document.getElementById("myBtn"); 
    var handler = function(){    
        alert("Clicked"); 
    }; 
    btn.attachEvent("onclick", handler); 
    btn.detachEvent("onclick", handler);
    ```

    

- **两个参数**：事件处理程序名称与事件处理程序函数



## 事件的优先级

- HTML事件会被属性事件覆盖，两种方法实现机制是一样的，只是写法不同，因此会覆盖
- 目标元素上的事件执行顺序按代码中绑定的顺序执行，不按捕获、冒泡的顺序执行
- 冒泡阶段事件若有HTML事件则其优先执行再被属性事件覆盖，再执行addEventListener()事件，因为事件的绑定是浏览器实现的，浏览器在执行整个网页的过程中先解析HTML；若没有HTML事件则按代码中绑定的顺序执行



## 事件对象

在触发DOM上某个事件时，会产生一个事件对象event，其中包含所有与事件有关的信息



### DOM中的事件对象

| 属性/方法                  | 类型         | 说明                                                         |
| -------------------------- | ------------ | ------------------------------------------------------------ |
| bubbles                    | Boolean      | 表明事件是否冒泡                                             |
| cancelable                 | Boolean      | 表明是否可以取消事件的默认行为                               |
| currentTarget              | Element      | 其事件处理程序当前正在处理事件的那个元素                     |
| defaultPrevented           | Boolean      | 为 true 表示已经调用了preventDefault() （DOM3级事件中新增）  |
| detail                     | Integer      | 与事件相关的细节信息                                         |
| eventPhase                 | Integer      | 调用事件处理程序的阶段：1表示捕获阶段，2表 示“处于目标”，3表示冒泡阶段 |
| target                     | Element      | 事件的目标                                                   |
| trusted                    | Boolean      | 为true表示事件是浏览器生成的。为false表 示事件是由开发人员通过JavaScript创建的 （DOM3级事件中新增） |
| type                       | String       | 被触发的事件的类型                                           |
| view                       | AbstractView | 与事件关联的抽象视图。等同于发生事件的 window对象            |
| preventDefault()           | Function     | 取消事件的默认行为。如果cancelable是 true，则可以使用这个方法 |
| stopImmediatePropagation() | Function     | 取消事件的进一步捕获或冒泡，同时阻止任何 事件处理程序被调用（DOM3级事件中新增） |
| stopPropagation()          | Function     | 取消事件的进一步捕获或冒泡。如果bubbles 为true，则可以使用这个方法 |

- 所有属性和方法**只可读不可写**
- 对象this始终等于currentTarget的值，而target则只包含事件的实际目标
- 调用stopImmediatePropagation()方法的事件之后的所有事件都不执行；而stopPropagation()只阻止事件向下层传播，当前节点的所有事件依然执行
- 只有在事件处理程序执行期间才有event对象，一旦事件处理程序执行完成，event对象就会被销毁



### IE中的事件对象

| 属性         | 类型    | 读/写 | 说明                                                         |
| ------------ | ------- | ----- | ------------------------------------------------------------ |
| cancelBubble | Boolean | 读/写 | 默认值为false，但将其设置为true就可以取消事件冒泡（与DOM中 的stopPropagation()方法的作用相同） |
| returnValue  | Boolean | 读/写 | 默认值为true，但将其设置为false就可以取消事件的默认行为（与 DOM中的preventDefault()方法的作用相同） |
| srcElement   | Element | 只读  | 事件的目标（与DOM中的target属性相同）                        |
| type         | String  | 只读  | 被触发的事件的类型                                           |

- IE中使用属性事件添加事件处理程序时，事件对象为window对象的一个属性，即window.event
- 使用attachEvent()添加时event对象作为参数被传入事件处理程序函数中，但也可以用window.event来访问
- returnValue没有办法确认事件的默认行为是否可以被取消