# 变量、作用域与内存问题

[TOC]

## 变量

变量包含两种不同数据类型的值：

- **基本类型值**

  指**简单数据段**。即Undefined、Null、Boolean、Number、String类型。

  这5种基本数据类型是**按值访问**的，可以操作保存在变量中的实际值，被保存在**栈内存**中。

- **引用类型值**

  指**对象**。值保存在**堆内存**中，不能直接操作对象的内存空间

  *当复制保存着对象的某个变量时，操作的是对象的引用；但在为对象添加属性时，操作的是实际的对象。



### 变量的创建和赋值

1. **创建**

   1. 创建命名
   2. 创建作用范围（作用域）
   3. 将创建变量的过程提至函数最顶部

2. **赋值**

   - 若值是基本类型值，则值被保存在变量中
   - 若值是引用类型值，则值被保存在内存中，同时创建内存地址即引用，然后将引用保存到创建出来的变量中

   

*通常变量的创建和赋值用一条语句来完成，如：`var a = 1;`



### 变量的操作

- **属性和方法的增删**

  - 若是基本类型值，不会报错，但没有效果
  - 若是引用类型值，解析器根据变量中保存的地址，在内存中找到保存的对象，再对对象进行属性和方法的增删操作。

- **变量的修改**

  - 变量的修改即给变量重新赋值
  - 修改变量是先将原变量销毁，再重新创建赋值
  - 若是修改引用类型值的某个属性，则是解析器根据变量中保存的地址，在内存中找到保存的对象，再进行修改

- **复制变量值**

  - 若是基本类型值，两个变量完全**独立**，参与任何操作**互不影响**。
  - 若是引用类型值，复制的只是变量的地址，再赋值给另一变量，两个变量实际上将**引用同一个对象**。虽然两个变量相互独立，但改变其中一个变量就会影响另一个变量。

- **参数的传递**

  - 传参即把函数外部的值**复制**给函数内部的参数，但所有函数的参数都是**按值传递的**

  - 解析器不关心函数参数的数据类型

  - 若传的参数是基本类型值，基本与复制类似，函数外部与内部变量相互独立互不影响

    ```javascript
    function addTen(num) {     
        num += 10;     
        return num; 
    } 
    var count = 20; 
    var result = addTen(count); 
    console.log(count);   //20，没有变化 
    console.log(result);  //30 
    ```

  - 若传的参数是引用类型值

    ```javascript
    function setName(obj) {     
        obj.name = "Nicholas";     
        obj = new Object();     
        obj.name = "Greg"; 
    } 
    var person = new Object(); 
    setName(person); 
    console.log(person.name);    //"Nicholas" 
    ```

    person.name的值并未修改，由此可以证明传参是**按值传递**，而不是按引用传递。当函数内部重写obj时，这个变量引用的就是一个**局部对象**了。而这个局部对象会在函数执行完毕后立即被销毁。



### 检测类型instanceof

- 是二元操作符

- `instanceof`主要用于检测引用类型；`typeof`无法精准检测引用类型，适合检测基本数据类型

- `instanceof`的用法

  ```javascript
  console.log(a instanceof Object);   // 变量a是Object吗？
  console.log(b instanceof Array);    // 变量b是Array吗？
  console.log(c instanceof RegExp);   // 变量c是RegExp吗？
  ```

- 在检测一个引用类型值和**Object**构造函数时，返回值永远是**true**，因为**所有引用类型值都是Object的实例**

- 如果检测的是**基本类型值**，返回结果永远是**false**，因为基本类型不是对象



## 作用域和执行环境

- 执行环境即执行上下文，定义了变量或函数有权访问的其他数据，决定了它们各自的行为。有**全局**执行环境和**局部**（函数）执行环境

- 作用域是用来规定变量和函数可访问范围的一套**存储规则**，ES5中没有块级作用域；作用域可以嵌套，不可以重叠

- **作用域和执行环境不是同一个东西**

- **变量对象**

  - 每个执行环境都有一个与之关联的变量对象，**环境中定义的所有变量和函数都保存在这个对象中**；若环境是函数，则其**活动对象**会作为变量对象，其中最开始只包含一个变量即`arguments`对象
  - 全局环境的变量对象始终存在；而函数这样的局部环境的变量对象则只在函数执行的过程中存在

- **作用域链**

  - 作用：保证对执行环境有权访问的所有变量和函数的**有序访问**（**访问规则**
  - 每进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链
  - 作用域链的前端是当前执行代码所在环境的变量对象，最后一个对象始终是全局执行环境的变量对象。搜索**从作用域链的前端开始逐级向后回溯**访问，寻找目标。
  - 内部环境可以通过作用域链访问所有外部环境，但外部环境不能访问内部环境。环境之间的联系是线性的、有次序的
  
- **函数的创建与调用过程**

  - **创建**

    在全局中创建一个函数，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在函数内部的`[[Scope]]`属性中

  - **调用**

    1. 为函数创建一个执行环境，然后通过复制函数的`[[Scope]]`属性中的对象，构建起执行环境的作用域链
    2. 该函数执行环境的活动对象（作为变量对象）被创建并推入作用域链的前端

  - 函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）

  ```javascript
  function compare(value1, value2){  
      if (value1 < value2){     
          return -1;     
      } 
      else if (value1 > value2){      
          return 1; 
      } 
      else {         
          return 0;   
      } 
  } 
   
  var result = compare(5, 10); 
  ```

  ![作用域链](F:\前端笔记\studyNote\images\作用域链.png)

- var声明的变量会自动被添加到最接近的环境中。若没有使用var声明，则会自动被添加到全局环境

- 变量的执行环境有助于确定应该如何释放内存



## 内存

- **自动垃圾收集机制**

  执行环境会负责管理代码执行过程中使用的内存。

  方式主要有：

  - **标记清除**

    目前主流垃圾收集算法。给当前不适用的值加上标记再回收其内存。

  - **引用计数**

    目前已经不怎么使用。可能出现问题，导致循环引用

- **手动解除**变量引用：将变量设置为`null`，这意味着切断变量与它此前引用的值之间的连接。

  解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处