# 剪绳子

[TOC]

## 题目

给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，2 <= n <= 60并且m>1，m<=n），每段绳子的长度记为k[1], ..., k[m]。请问k[1] \* ... \* k[m]可能的最大乘积是多少？

例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18





## 示例

- **输入**

  8

- **返回值**

  18

- **描述**

  输入n返回最大乘积



## 解法

- **动态规划**

  - **思路**

    设长度为n的绳子剪后最大乘积为f(n)

    给绳子剪第一刀，绳子分成两段。如果第一段长度为1，第二段长度就为n-1，乘积为f(1)\*f(n-1)；如果第一段长度为2，第二段长度就为n-2，乘积为f(2)\*f(n-2)...

    以此类推，f(n) = max(f(i)*f(n-i))

    当n<=4时，没必要再剪。因为剪后乘积小于不剪。例如n=2时，剪一刀1\*1=1，不剪就是2，所以直接返回本身；n=4时，剪一刀最大2\*2=4，不剪就是4，所以也直接返回本身

  - **代码**

    ```javascript
    function cutRope(number)
    {
        // write code here
        if(number==2)
            return 1;
        if(number==3)
            return 2;
        var max = 0;
        var f = [];
        f[0]=0;
    	f[1]=1;
    	f[2]=2;
    	f[3]=3;
        for(let n = 4; n <= number; n++){
            for(let i = 1; i <= Math.floor(n/2); i++){ //只需要前一半，剪i和剪n-i是一样的
                var temp = f[i]*f[n-i];
                if(temp > max)
                    max = temp;
                f[n] = max;
            }
        }
        return f[number];
    }
    ```

- **数学方法**

  - **思路**

    ```javascript
    /*
     * 举例子找规律:
     * 4 ：2*2
     * 5 ：2*3
     * 6 ：3*3
     * 7 ：2*2*3 或者4*3
     * 8 ：2*3*3
     * 9 ：3*3*3
     * 10：2*2*3*3 或者4*3*3
     * 11：2*3*3*3
     * 12：3*3*3*3
     * 13：2*2*3*3*3 或者4*3*3*3
     * 由规律可知其实都可以拆分成2和3，且2的数量肯定小于3，因为2*2*2 < 3*3
    */
    ```

    所以，同样当绳子段长 ≤ 4时没必要再剪

    当绳子 ≥ 5时，把所有的绳子长度都剪成2或3，同时要尽可能的多剪长度为3的绳子

  - **代码**

    ```javascript
    function cutRope(number)
    {
        // write code here
        if(number==2)
            return 1;
        if(number==3)
            return 2;
        if(number==4)
            return 4;
        var max = 1;
        while(number >= 5){
            number -= 3;
            max *= 3;
        }
        return max*number;
    }
    ```

    