# 斐波那契数列及相关题目

[TOC]

## 题目

要求输入一个整数n，请输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。（n≤39）



## 示例

- **输入**

  4

- **返回值**

  3



## 相关知识

### 斐波那契数列

又称黄金分割数列，递推的方法定义：*F*(0)=0，*F*(1)=1, *F*(n)=*F*(n - 1)+*F*(n - 2)（*n* ≥ 2，*n* ∈ N*）



### 动态规划

- **使用条件**

  - **最优化原理**

    问题的最优解所包含的子问题的解也是最优的，则该问题具有最优子结构，即满足最优化原理

  - **无后效性**

    某阶段状态一旦确定，就不受这个状态以后决策的影响

  - **有重叠子问题**

    子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到（不是必要条件）



## 解法

- **动态规划**

  时间复杂度：O(n)，空间复杂度O(1)

  ```javascript
  //1.
  function Fibonacci(n)
  {
      // write code here
      var a = 0, b = 1;
      for(var i = 1; i <= n; i++){
          a = a + b;
          b = a - b;
      }
      return a;
  }
  
  //2.
  function Fibonacci(n)
  {
      // write code here
      if(n == 0 || n == 1)
          return n;
      var a = 1, b = 1, c;
      for(var i = 2; i <= n; i++){
          c = a+b;
          a = b;
          b = c;
      }
      return a;
  }
  ```

- **递归**

  时间复杂度为O(2^n)，空间复杂度为递归栈的空间，缺点是慢、会超时

  ```javascript
  function Fibonacci(n)
  {
      // write code here
      if(n == 0|| n == 1)
          return n;
      return Fibonacci(n-1)+Fibonacci(n-2);
  }
  ```



## 相关题目

### 1.跳台阶

#### 题目

一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）

#### 示例

- **示例1**

  - **输入**

    1

  - **返回值**

    1

- **示例2**

  - **输入**

    4

  - **返回值**

    5

#### 思路

题目就是斐波那契数列

- 两种跳法，1阶或者2阶
- 假定第一次跳的是一阶，那么剩下的是n-1个台阶，跳法是f(n-1)
- 假定第一次跳的是2阶，那么剩下的是n-2个台阶，跳法是f(n-2)
- 由上面两个假设可以得出总跳法为: f(n) = f(n-1) + f(n-2)
- 然后通过实际的情况可以得出：只有一阶的时候 f(1) = 1，只有两阶的时候可以有 f(2) = 2

因此实现方法与实现斐波那契数列一样



### 2.变态跳台阶

#### 题目

一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法

#### 示例

- **输入**

  3

- **返回值**

  4

#### 实现

- **思路**

  原理与斐波那契数列相似，青蛙只跳1或2可以得出a[n]=a[n-1]+a[n-2]，那么能跳1,2,3个台阶时a[n]=a[n-1]+a[n-2]+a[n-3]，则：

  a[n]=a[n-1]+a[n-2]+......+a[1];  ..........................①

  a[n-1]=a[n-2]+......+a[1];           ..........................②

  两式相减可知：a[n]=2*a[n-1];

- **代码**

  ```javascript
  function jumpFloorII(number)
  {
      // write code here
      if(number == 0 || number == 1)
          return 1;
      var a = 1;
      for(var i = 2; i <= number; i++){
          a*=2;
      }
      return a;
  }
  ```

#### 其它解法

- **暴力法**

  - **思路**

    设f[i]表示当前跳道第 i 个台阶的方法数。则答案为f[n]。

    假设现在已经跳到了第 n 个台阶，那么前一步可以从哪些台阶到达呢？

    如果上一步跳 1 步到达第 n 个台阶，即上一步在第 n-1 个台阶，则跳到第n-1个台阶的方法数为f[n-1]

    如果上一步跳 2 步到达第 n 个台阶，即上一步在第 n-2 个台阶，则跳到第n-2个台阶的方法数为f[n-2]

    ...以此类推...

    如果上一步跳 n 步到达第 n 个台阶，即上一步在第 0 个台阶，则跳到第0个台阶的方法数为f[0]

    则总的方法数就是所有可能的和，即f[n] = f[n-1] + f[n-2] + ... + f[0]

    初始条件f[0] = f[1] = 1

  - **代码**

    ```javascript
    function jumpFloorII(number)
    {
        // write code here
        if(number == 0 || number == 1)
            return 1;
        var f = new Array(number+1);
        f[0] = f[1] = 1;
        for(var i = 2; i <= number; i++){
            f[i] = 0;
            for(var j = 0; j < i; j++){
                f[i] += f[j];
            }
        }
        return f[number];
    }
    ```




### 3.矩形覆盖

#### 题目

可以用2\*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2\*1的小矩形无重叠地覆盖一个2\*n的大矩形，总共有多少种方法？

#### 示例

- **输入**

  4

- **返回值**

  5

#### 思路

![矩形覆盖题思路](F:\前端笔记\studyNote\images\矩形覆盖题思路.png)

因此原理与斐波那契数列一样，只是初始值不一样，初始值f(1)=1,f(2)=2

#### 代码

```javascript
function rectCover(number)
{
    // write code here
    if(number <= 2)
        return number;
    var a = 1, b = 2, c;
    for(var i = 3; i <= number; i++){
        c = a + b;
        a = b;
        b = c;
    }
    return c;
}
```

